# 15.0. 前言

何为 ***pointer*** ：

- ***pointer*** 就是指针
- 是对某一种变量的统称，这种变量存储了某个内存地址，该地址引用或指向其它数据



引用是最常用的指针：

- Rust 中最常用的指针就是 Chapter4 中的引用
- 引用通过 & 来标识，并借用所指向的数据
- 除此之外，引用没有其它的功能，而且不会带来额外的性能损耗



何为 ***smart pointer*** ：

- ***smart pointer*** 就是智能指针
- 智能指针也是指针，但与指针不同的是，它是一种数据结构，包含了额外的 metadata ，也具备了比指针更多的功能
- 智能指针不是 Rust 独有的概念，它起源于 C++ ，并在很多语言中都存在
- Rust 标准库中定义了多种智能指针，提供了远超于引用的更多功能
- 例如，本章会讲解一种智能指针叫 reference counting ，这种智能指针允许一份数据存在多个所有者，并跟踪所有者的数量，当该数据已经不存在所有者时，就销毁该数据



引用与智能指针：

- Rust 使用了所有权和借用的概念，所以引用和智能指针有显著区别
- 引用是一种指针，只能 borrow 数据
- 反过来，大多数智能指针虽然也是指向数据，但可以 own 数据；



智能指针举例：

- 到目前为止，本书内容已经涉及过一些智能指针
- 例如Chapter8 中的 `String` 和 `Vec<T>` ，但并没有直接称呼它们为智能指针
- 但事实上，这些类型可以视作智能指针，因为它们拥有内存并允许操作这些内存
- 而且拥有 metadata ，例如 `Vec` 可存储容量
- 还具备其它的能力，例如 `String` 总是能确保其数据是有效的 UTF-8 编码



智能指针的实现：

- 智能指针一般通过 struct 来实现
- 但二者最大的不同是，智能指针实现了 `Deref` 和 `Drop` 这两个 trait 
- `Deref` 允许结构体实例具备引用的特性，从而该结构体可以是一个引用，也可以是一个智能指针
- `Drop` 允许定义当结构体实例离开生存周期时的行为
- 本章会讲解这两个 trait 并可以看到它们对于智能指针的重要性



在 Rust 中经常会使用智能指针这种通用设计模式，因此很多库都有自己的智能指针，甚至你也可以实现自己的智能指针。所以本章只会讨论标准库中最常用的如下几种智能指针：

- `Box<T>` 可以在 heap 中分配内存和数据
- `Rc<T>`, 一种 reference counting 类型，可以存在多个所有者
- `Ref<T>` and `RefMut<T>`, 通过 `RefCell<T>` 来访问，这种智能指针在运行时执行借用规则，而不是在编译时



其它内容：

- 本章还会涉及到 ***interior mutability*** ，也就是一个非 mut 类型可以提供API，通过 API 来改变内部数据
- 还会讨论 ***reference cycle*** ，它会如何导致内存泄露，以及如何避免