# 使用 ***Box***

关于 ***box*** ：

- 它是最简单直观的智能指针
- 对应的类型是 `Box<T>`
- 它允许将数据存储在 heap 中而不是 stack 中
- 当然，这个智能指针本身是存储在 stack 中，然后它指向 heap 中的数据
- 除了将数据存储在 heap 而不是 stack 之外，它不会带来额外的性能损失；但同时，它也不再具备其它能力



使用 ***box*** 的场景：



> 对大量数据进行所有权转移时，不希望这些数据被拷贝

- 对大量数据进行所有权转移时，会耗费很多时间来拷贝到 stack
- 改进的办法是，使用 box 将这些数据存储在 heap 中
- 从而在转移所有权时，只有对应的少量指针会被拷贝到 stack ，而所指向的数据仍然在 heap 中



> 无法在编译时知道某种数据类型的大小，但是在某种场景下，要访问该数据类型的值时，却需要知道该类型的精确大小

- 后续关于「Recursive Type」的章节中会讲解这种场景



> 在 own 某个数据时，只关心这种数据类型实现了某些 trait ，而不关心具体是哪一种数据类型

- Chapter17 一整章都是讲解这种场景



## 存储数据到 Heap

先看 `Box<T>` 的语法及如何访问存储在里面的值：

```rust
fn main() {
    let b = Box::new(8);
    println!("{}", b);
}
```

数据关系：

1. 变量 b 的值是一个 box 
2. 该 box 指向数据 8 
3. 而 8 这个数据存储在 heap 中

例子剖析：

- 该例子打印结果是 `b = 8`
- 也就是说，可以直接访问 box 中的数据，就像该数据是存储在 stack 中一样

数据销毁机制：

- 与 own 机制一样，当 box 离开生存范围时，该 box 就会被销毁
- 在该例子中，b 离开 `main` 之后，b 就会被销毁
- 销毁的内容包括：第一，box 本身，也就是变量 b ，存储在 stack 中；第二，box 也就是 b 所指向的数据，存储在 heap 中

补充：

1. 该例子将一个简单数据类型存储在 box 中，这仅仅只是为了演示，因为这种做法没有意义
2. 对于像 `i32` 这种简单数据类型，更合适的方式是让它默认存储在 stack 中
3. 后续会展示一些更有用的场景，可以看到只有通过 box 才能定义一些数据类型，而不使用 box 就无法做到



## 使用 Recursive Type

