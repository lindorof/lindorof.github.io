---
sidebar: auto
sidebarDepth: 2
---

# 多维数组 & 多维指针

## 引言

- C的世界里，是没有所谓多维数组概念的，永远都是一维数组，或者说其实都是一维指针，通过一维指针来进行寻址；
- 而所谓的多维指针，可以理解为只是编译器为了方便程序开发，而对一维数组进行的二次包装而已；



## 一维数组  

定义方式：

```cpp
type t[1025];
```

说明：

- 此时 `t` 的内存分配是连续的，大小是 `1025 * sizeof(type)` ；
- 要索引第 x 个元素时，地址是 `t + x * sizeof(type)` ；



## 二维/多维数组  

定义方式：

```cpp
type t[10][1025];
```

说明：

- 此时 t 的内存分配是连续的，大小是 `10 * 1025 * sizeof(type)` ；
- 也就是说，其实可以理解为一维数组 `type t[10 * 1025]` ；
- 但是既然定义为二维数组，那么编译器就支持按照二维数组的方式去索引；
- 因此索引方式是第 x 维的第 y 个元素，即 `t[x][y]` ，地址是 `t + (x * 1025 + y) * sizeof(type)` ；

所以：

- 可以定义一个一维数组，但是强转为二维数组类型，并按照 `t[x][y]` 的方式去索引元素；
- 也可以定义一个二维数组，但是强转为一维数组类型，并按照 `t[x]` 的方式去索引元素；
- 因为不管几维数组，本质都是一维数组；



## 一维指针  

定义方式：

```cpp
type* t;
```

说明：

- 一旦类型为指针，则内存分配不一定是连续的，取决于指针的实际类型；
- 可能是数组，可能是被重载过运算符 `[]` 的链表；
- 假设内存分配是连续的，则 `t[x]` 的索引方式是：`t + x * sizeof(type)` ；



## 二维/多维指针  

定义方式：

```cpp
type* t;
```

说明：

- 如果 `type` 是 `char*` ，则二维指针就是 `char** t` ；
- 所以，本质还是指针；



## N维指针的本质 

- 没有二维/多维指针的概念，永远都是指针，指针指向某种元素类型；
- 因此，如果指针所指向的元素类型也是指针，则从定义方式上看就像多维指针；
- 所以，对于 `type* t` ，索引该指针的第 x 个元素，地址就是：`t + x * sizeof(type)` ；



## 数组与指针的转换  

> 一维数组与指针

- 数组：`type t1[1025]` 
- 指针：`type* t2` 
- 则 `t1` 与 `t2` 是等价的；
- 对指针来说，丢失了实际数组大小的信息；

> 二维数组与指针

- 数组：`type t1[10][1025]`
- 可以转换为：`type t2[][1025]`
- 可以转换为：`type (*t3)[1025]`
- 则 `t1` 、`t2` 、`t3` 是等价的；
- 也就是说，第二维的大小都是必须定义的，但第一维的本质其实也就是指针，只是这个指针指向的是一个 `[1025]` 的数组；
- 对 `t2` 来说，第一维可以定义，也可以忽略；
- 对 `t3` 来说，第一维的大小是丢失的，此时 `t3` 是一个指向数组的指针
- 也就是说 `t3` 这个指针，指向的元素类型是 `[1025]` 的数组；

> 多维数组与指针

- 依据二维的规则类推；
- 数组：`type t1[10][20][1025]` 
- 可以转换为：`type t2[][20][1025]` 
- 可以转换为：`type (*t3)[20][1025]` 
- 总之，***只有第一维的大小可以省略，后续的维度大小都必须声明清楚*** ；



## 总结  

> 先重申下述结论

- 所谓的多维数组，本质都是一个内存连续的一维数组，而多维数组的 `t[x][y]` 用法只是编译器提供的福利；
- 所谓的多维指针，本质都是指针，没有维度的概念，只是指向某种元素的指针；
- 数组和指针的区别，本质就是 ***寻址方式*** 的区别；

> 数组的寻址方式

- `type t[1025]` ，则 `t[x]` 的寻址方式是：`t + x * sizeof(type)` 
- `type t[10][1025]` ，则 `t[x][y]` 的寻址方式是：`t + (x * 1025 + y) * sizeof(type)` 

> 指针的寻址方式

- `type* t` ，则 `t[x]` 的寻址方式是：`t + x * sizeof(type)` 



## 陷阱

> 二维数组不能直接强转为二维指针，因为寻址方式不同：

- `char t[10][1025]` ，在使用 `t[x]` 时，编译器会自动进行 `x*1025` 的地址跳转；
- `char** t` ，在使用 `t[x]` 时，编译器只会进行 `t + x * sizeof(char*)` 的跳转；

> 所以，多维数组转换为指针时要注意：

- 只有第一维的大小能够忽略
- 剩余其它维的大小都必须保留
- 因为必须告知其它维度的大小，编译器才能有效的进行地址跳转

