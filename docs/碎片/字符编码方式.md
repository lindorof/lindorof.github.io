---
sidebar: auto
sidebarDepth: 2
---

# 字符编码方式

## ANSI / ASCII

- 一个字符使用一个字节；

- 字节范围为127 即 0x7F 以下，包括了空格、标点符号、数字、大小写字母等；

- 其中，0x20 以下的字节为控制码，例如：

    - 0x10 表示终端换行；

    - 0x07 发出蜂鸣；

    - 0x1b 反白显示；



## GB2312

- 一个小于127的字符的意义与ASCII相同；

- 两个大于127的字符连在一起时，就表示一个汉字；

    - 前面的一个字节（高字节）从0xA1用到0xF7

    - 后面一个字节（低字节）从0xA1到0xFE

- 包括了常见的6000多个汉子，还包括了数学符号、罗马希腊字母、日文假名等；

- 「全角」和「半角」
    - ASCII 里的数字、标点、字母也重新编了两个字节长的编码，这就是常说的”全角”字符；
    - 而ASCII原来在127号以下的那些字符就叫”半角”字符；



## GBK

- 与GB2312一致，但是只要高字节大于127就表示一个汉字的开始，低字节可以小于127；

- GBK包括了GB2312的所有内容，即向下与GB2312兼容，但同时又增加了新的汉字（包括繁体字）和符号；



## GB18030

> 概述：

- GB18030-2000 是2000年发布；
- GB18030-2005 是2005年发布；
- GB18030 是一、二、四 个字节变长的编码；

    - 一个字节时，与 ASCII 编码兼容。
    - 二个字节时，与 GBK 标准兼容。
    - 四个字节时：
        - 第一个字节从 0x81 到 0xFE
        - 第二个字节从 0x30 到 0x39
        - 第三个字节从 0x81 到 0xFE
        - 第四个字节从 0x30 到 0x39。

> 注意：

- GB2312/GBK/GB18030这一系列中文编码统称“DBCS”（Double Byte Charecter Set 双字节字符集）；
- 在DBCS系列标准里，最大的特点是多字节的汉字字符和一字节的英文字符并存于同一套编码方案里；
- DBCS要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个多字节字符集里的字符出现了；
- 即所谓的一个汉字算多个英文字符；



## UNICODE

- UNICODE 是ISO制定的编码方案，叫做 Universal Multiple-Octet Coded Character Set ，简称 UCS ，俗称 UNICODE ；
- UNICODE只考虑为每个字符定义编码，使用了0-65535的数字，刚好是计算机两个字节的大小；
    - 其中0至127表示的字符仍然跟ASCII一样，例如 0X41 仍然是 A，表示为 U+0041；
    - 而其它字符例如「汉」，编码是 27721，即 0x6C49，表示为 U+6C49；

- 由于两个字节只能容纳 65535 个字符，因此1996年制定了 UNICODE 第二个版本，用四个字节表示所有字符；
- 但是UNICODE并不考虑如何存储，也就是说，虽然通过两个/四个字节表示了所有字符，但是有两个问题：
    - 第一，如果有所有字符都统一使用两个/两个字节来存储，那么对于英文字符来说会造成存储空间极大的浪费；
    - 第二，如果不统一使用两个/四个字节来存储，那么则无法区分多个字节究竟是多个字符还是一个字符；

- 因此，基于UNICODE编码，出现了基于存储和传输的 ***UTF*** ( ***unicode transformation format*** ) 标准；



## UTF-8

> 存储规则：

- 一个字符可能使用一个或多个字节来表示：
    - `0xxxxxxx`，一个字节表示一个字符，与ASCII一致；
    - `110xxxxx 10xxxxxx`，两个字节表示一个字符；
    - `1110xxxx 10xxxxxx 10xxxxxx`，三个字节表示一个字符；
    - `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`，四个字节表示一个字符；

- 因此，字节与容量的关系是：
    - 一个字节能表示 2 的 7 次方 即 128 个字符
    - 两个字节能表示 2 的11次方 即 2048 个字符
    - 三个字节能表示 2 的 16 次方，65536个字符；

- 因此，对于两个字节编码的 UNICODE 字符来说，采用 UTF-8 可能需要 1-N 个字节来存储，例如 6 个字节；而对于 UNICODE 不断增加的字符编码，UTF-8都能够持续兼容；

> 举例说明：

- 例如，「汉」的 UNICODE 编码是 27721 ，大于 2048 ，所以需要三个字节来存储；
- 因此，要用 `1110xxxx 10xxxxxx 10xxxxxx` 这种格式，把 27721 对应的二进制 ***从左到右*** 填充；



## UTF-16

- 任何字符都按照 UNICODE 编码用两个字节来保存，因此 UTF-16 也叫 UCS-2 ；
- 因此对于英文字母来说存在存储空间的极大浪费；
- 例如，「汉」的编码是 27721 ，即 0x6C49 ，那么用 UTF-16 存储就是 6C 49；
- UTF-16 能兼容的 UNICODE 编码是有限的，因为只有两个字节；



## UTF-32

- 与 UTF-16 的原理一致，但任何字符都使用四个字节来保存，因此 UTF-32 也叫 UCS-4 ；
- 因此 UTF-32 能兼容目前所有的 UNICODE 编码，因为使用了四个字节；
- 但同样，存储空间也存在极大的浪费；



## BOM

> 概述：

- UTF-8以单字节作为编码单元，不存在高低位的顺序问题；
- UTF-16 / UTF-32 以 2 个或 4 个字节作为编码单元，因此由于硬件CPU的不同，存在字节顺序的问题；

- 因此，***BOM***（***byte order mark***）用来表示字节顺序；

> 以 `‭0100 1110 0010 1101`‬ 即 `0x4E2D` 为例：

- FE FF , ***Big endian*** , 大端，从左到右，4E 2D ;
- FF FE , ***Little endian*** , 小端，从右到左，2D 4E ;

> 常见的几种 BOM ：

- UTF-8  : EF BB BF (***UTF-8可以没有BOM***)
- UTF-16 : FE FF (***Big endian***)
- UTF-16 : FF FE (***Little endian***)
- UTF-32 : 00 00 FE FF (***Big endian***)
- UTF-32 : FF FE 00 00 (***Little endian***)

