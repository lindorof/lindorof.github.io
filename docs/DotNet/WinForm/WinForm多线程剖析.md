---
sidebar: auto
sidebarDepth: 2
---

# WinForm多线程剖析

*如有谬误，请谅解并指正。*



## 有坑先填

无比惊讶的发现：

- WinForm 窗体判断某个操作是否是跨线程执行，依据是 `new Form()` 时所在线程
- 而不是消息循环（或者 `ShowDialog` ）所在的线程

也就是说：

```csharp {1,4}
LYForm f = new LYForm();
new Action(() =>
{
	f.ShowDialog();
}).BeginInvoke(null, null);
```

那么：

- 这个时候当前线程（即 `new LYForm()` 的线程）需要操作 `LYForm` 窗体时，并不需要`f.Invoke()`
- 这个时候如果调用 `f.Invoke()` ，执行是没有效果的，甚至会抛出异常



## 子线程如何控制UI

如果子线程中需要访问到 UI ：

- 则使用 `Controls.Invoke` 或者 `Controls.BeginInvoke` 
- 从而，`Invoke` 或 `BeginInvoke` 会调度给 UI 所属的线程来执行

例如，对于某个FORM：

- 可以 `this.Invoke`
- 也可以 `this.button1.Invoke`



## 如何判断是子线程控制

方法：

```csharp
Controls.InvokeRequired
```

可以判断方法的调用是从主线程发起的，还是子线程发起的。



## 何为主线程

- 主线程是为 FORM 窗体进行消息循环的线程
- 一个 WINFORM 程序启动时，会自动建立一个消息循环的线程，在该主线程中创建的所有的 FORM 都使用这个消息循环
- 如果在子线程中进行 `ShowDialog()` ，则该子线程就成为该 FORM 的消息循环线程；
- 注意，`Form.Show()` 是不会建立消息循环的



## 窗体的消息响应

> 窗体自身的事件(例如鼠标点击/按钮点击等)

- 由窗体的消息循环线程处理
- 因此窗体自身的事件响应函数也是由自身的消息循环线程来调用
- 所以，窗体自身的事件响应函数不必考虑跨线程访问 UI 的问题

> 如果窗体的某些 UI 处理函数被外部调用

- 则这些函数被调用时，并不清楚是窗体自身的消息循环发起，还是外部跨线程的调用发起
- 此时，就需要使用 `Controls.InvokeRequired` 来判断，并对应的使用 `Controls.Invoke` 或 `Controls.BeginInvoke` 来进行 UI 访问



## 陷阱

如果 FORM 使用了托盘，则需要注意：

- 托盘的事件（例如鼠标右键点击、托盘菜单响应等）总是由总进程的主线程来响应的
- 因此，如果 FORM 不是在总进程的主线程中创建的，则托盘事件是触发不到的，但是窗体自身的事件可以被捕获和触发
- 所以，如果 FORM 使用了托盘，则 FORM 必须在总进程的主线程中创建



## 进阶

> 窗体如何响应用户的界面操作？

原理：

- 窗体创建后，可以有按钮点击、界面拖动等用户控制行为，这些行为都以消息的形式放入窗体的消息队列中
- 窗体自身的消息循环线程会不断的从消息队列里取出消息，并调用对应的消息处理函数进行处理
- 一个消息处理完毕后，接着处理消息队列里的下一个消息

举例：

- WINFORM 窗体上放置一个 BUTTON ，设计时双击 BUTTON ，即可为该 BUTTON 的点击事件编写处理函数 `F` 
- 因此，该窗体运行时，点击 BUTTON ，`F` 被执行，而这个过程真正的行为是：

    1. 首先，BUTTON 被点击，产生 CLICK 事件

    2. 其次，该 CLICK 事件被放入消息队列中

    3. 最后，消息循环线程取出该 CLICK 事件，并调用对应的处理函数 `F` 

    4. 所以，这个过程因为太快，给人感觉像是按钮按下后直接调用了一个 UI 函数一样



> 为何耗时的界面处理函数会导致界面失去响应？

- 消息线程是串行的处理队列中的消息
- 消息线程在调用消息处理函数未返回时，队列中的其它消息不会被处理
- 因此，当一个消息处理函数时间较长时，在未返回的情况下，点击界面另一个按钮，则按钮 CLICK 事件被放入消息队列
- 但是按钮 CLICK 事件一直未被处理，于是窗体一直处于等待状态，直到按钮 CLICK 事件被处理
- 因此，就看到界面失去响应的现象



> 为何 .NET 中不允许跨线程访问 UI ？

- 跨线程操作 UI 时，.NET 会抛出异常，不允许跨线程访问，认为不安全
- 而其实这是最基本的线程安全原理，好比多个线程同时访问一个对象一样，可能带来并发错误
- 因此 .NET 希望只使用一个线程，串行地依此处理 UI 控制请求，从而避免并发问题



> .NET 跨线程控制 UI 的原理？

- WIN32 时代，解决多线程并发的最直观思路，就是将来自五湖四海的请求统一扔到一个队列中，然后用一个线程串行的从队列中取出请求并处理，所以，归根结底还是生产者消费者这个经典模式
- 所以，所谓的 `Controls.Invoke` 看似很神奇的就解决了跨线程 UI 访问问题，其实本质上，该函数就是做了一个「将 UI 访问的请求放到窗体的消息循环队列中并等待直到被处理」这个动作，而 `BeginInvoke` 则只是将请求放入队列，不等待执行
- 大道至简，不管是简陋的 WIN32 时代，还是华丽的 .NET 时代，甚至现在时髦的 WPF 时代，都是基于最根本的生产者消费者这个经典原理



> WIN32 窗体的跨线程控制 UI 呢？

- WIN32 的窗体 UI 控制也是一样的原理，有自己的消息循环线程，串行依次处理 UI 消息
- 但是，WIN32 的窗体并未像 .NET 一样强行限制了跨线程的 UI 访问，但并不是说不存在并发问题，而是将并发控制过程交给程序员自己保证
- WIN32 的窗体里，其实一直都有类似 .NET 的 `Controls.Invoke` ，也就是 `SendMessage` 和 `PostMessage` ，分别对应 .NET 里的 `Controls.Invoke` 和 `Controls.BeginInvoke` ，众里寻他千百度，暮然回首那人却在灯火阑珊处



> 山高月小，水落石出

- 一直接受着 WIN32 的各种熏陶，一直坚信，所谓的线程其实就是一个方法的执行过程而已，方法执行完了，线程也就完毕了
- 但是 .NET 的 `Control.Invoke` 方法的注释是「让主线程来执行对应的 UI 请求」，这个注释实在太时髦了，让人一度迷茫，难道 .NET 里这个强大的 UI 主线程在执行过程中还可以换一个线程方法么？甚至一度求证异步 DELEGATE 、线程、线程池，发现不管怎么变花招，本质都是开启一个线程去执行一个方法而已
- 所以，线程是一种理论，理论模型决定了功能，而不会因为语言和语法的不同而导致功能的超越
- 看着强大的 `Controls.Invoke` ，一度以为真的可以让 UI 处理方法穿越般的跑到主线程中去执行，甚至纳闷为何 WIN32 API 就没这么强大的功能？也差点鄙视了自己「自行建立一个请求队列，将多个线程的请求放到队列中，并由一个唯一的线程依次处理请求」的想法，其实自己这个想法一直都是对的，只是 .NET 和 WIN32 都已经做好了，就是消息队列，只是自己以前理解不深刻而已



## 错误举例

> 忠告：不管是用户界面操作所触发，还是子线程用 `Controls.Invoke` 来触发，这些操作最后都是放到界面消息队列里，依次串行被处理的，因此要小心出现死锁的情况。

例如，有 A 线程，在循环访问界面：

```csharp {5}
new Action(() =>
{
	while (this.SimFuncRun == true)
	{
		this.Invoke(new Action(() => { this.Text = "XXX"; }));
	}
	this.SimFunEnd = true;
}).BeginInvoke(null, null);
```

同时，有 B 按钮，点击时等待 A 线程结束：

```csharp {2}
this.SimFuncRun = false;
while (this.SimFunEnd != true)
{
	Thread.Sleep(1);
}
```

则上面的代码必然导致死锁：

- 因为 B 按钮点击时，等待 A 线程停止

- 但事实上，A 线程刚好正在访问界面

- 然而，A 线程的操作和 B 按钮点击的操作都被放到消息队列中，依次排队执行

- 所以，在 B 按钮点击的操作未结束之前，A 线程的操作是不会被执行的，从而 A 线程无法被结束

针对该例子，有多种解决办法，例如：

1. 在 B 按钮点击时，只设置 A 线程的停止标记，但不等待 A 线程结束
2. 为了界面控制的严谨性，在 A 线程停止之前，不允许再次点击 B 按钮，则可以在 B 按钮点击时，先将 B 按钮禁用，并设置 A 线程的停止标记，然后立即返回
3. 在 A 线程中，执行结束时，将 B 按钮启用

