# 网络编程概念汇总

*根据学习网络上大量的碎片知识，进行汇总和梳理。*



## 阻塞/非阻塞/IO多路复用/异步

### 基础

它们并不是独立存在的多种网络I/O，只是描述的方式不同而已。首先明确基础概念：

1. 进行网络I/O时，例如读、写，存在两个基本动作：
    - 判断是否就绪，例如当前是否有数据到达，从而可读；
    - 数据就绪后，将数据读出，进行后续处理；

2. 网络I/O操作在操作系统中存在两个层面的切换：
    - 内核层，进行I/O状态判断，数据读写等；
    - 用户层，对内核层进行状态判断、数据读写的请求操作等；

### 阻塞

1. 发起IO请求，开始阻塞；
2. 等待内核层状态就绪；
3. 状态就绪后拷贝数据到用户层；
4. 阻塞结束；

### 非阻塞

1. 发起IO请求，立即返回；
2. 不断的主动询问内核层状态是否就绪；
3. 若状态就绪，拷贝数据到用户层；

### IO多路复用

1. 针对非阻塞的方式进行改进，因为非阻塞方式需要主动的不断询问内核层状态，当fd较多时不便于处理；
2. 将要处理的多个fd交给内核层，内核层同时查看多个fd是否有就绪的，而用户层阻塞；
3. 若有就绪的fd则结束阻塞，用户层针对就绪的fd进行处理；

### 异步

1. 用户层发起IO请求，立即返回；
2. 内核层自行等待状态就绪并处理数据例如拷贝；
3. 结束后发起回调，告知用户层；

### 总结

1. 看似术语很多，其实只有三种：阻塞，非阻塞，异步；
2. IO多路复用只是针对非阻塞的改进方式，例如select,poll,epoll；其中epoll是linux提供的方式；
3. 异步只有Windows的IOCP做了很好的实现；
4. 所谓的同步和异步，就看如何理解:
    - 可以认为阻塞、非阻塞、IO多路复用都是同步，因为同步过程要不是等待内核层数据就绪（例如阻塞），要不就是从内核层同步的拷贝数据（例如非阻塞）；
    - 也可以认为只有阻塞式是同步，其它的都是异步；
    - 也可以认为只有Windows的IOCP才是异步，其它的都是同步；



## select/poll/epoll

都是IO多路复用的方式，只有Windows的IOCP是真正的异步IO，因此详细说明几种IO多路复用的区别。

### select

1. 使用数组存储fd，个数有限制，32位系统是1024个，64位系统是2048个；
2. 每次进行select时，将fd全部拷贝进内核层；
3. 内核层将所有的fd遍历一遍，针对就绪的fd，设置对应就绪标记，例如读，写，错误等；
4. 若都没有任何fd就绪，则阻塞并睡眠一段时间后继续轮询；
5. 有任何fd就绪，则返回；
6. 所以轮询fd的时间复杂度是O(n)；

### poll

1. 使用链表存储fd，因此个数没有限制；
2. 其它方面和原理包括时间复杂度都与select完全相同；

### epoll

1. epoll的意思就是event poll，是对poll的改进；
2. 不用重复拷贝全部fd进内核层，而是在有新的fd时，挂接进内核层；
3. 因此fd的存储空间是内核层和用户层共享的一片内存；
4. 对于fd的个数也没有限制；
5. 内核层会为每个fd指定一个回调，在该fd就绪时，回调被触发，然后把fd放到一个就绪链表中；
6. 从而epoll的时候，内核层不是在轮询所有fd，而是只轮询就绪链表；
7. 因此针对就绪fd的查询上，时间复杂度为O(1)；因为某个fd就绪时会自动被加入到就绪链表中，从而epoll立即检测到有就绪的fd；
8. 但是，如果活跃的fd很多，那么就绪链表也会增大，从而影响性能，因此针对这个问题，epoll提供LT和ET，即水平触发和边缘触发两种方式；
9. 水平触发的意思是，只要就绪的fd未被处理，则会重复触发，所以如果就绪链表增大，那么性能也会收到影响；
10. 边缘触发的意思是，就绪的fd只会被触发一次，直到第二次就绪状态到达，从而用户层可以只处理自己关心的fd；

### 总结

1. 关于fd在内核层与用户层之间的重复拷贝和挂接：selecet和poll每次调用时都需要重复拷贝和挂接fd，但epoll针对每个fd只需要拷贝和挂接一次；
2. 关于fd在内核层与用户层之间的内存关系：select和poll每次调用时都需要将用户层的fd内存拷贝到内核层的fd内存，而epoll则在内核层和用户层之间共享fd内存，用户层只需要将新的fd挂接到该共享的内存中；
3. 关于fd的轮询方式：select和poll轮询的是所有的fd，时间复杂度是O(n)，epoll中由fd就绪时会自动触发回调进而被加入就绪链表，因此时间复杂度是O(1)，所以epoll轮询的是就绪的fd而不是全部fd；
4. 关于fd的存储方式：select使用数组，大小有限制，32位系统是1024，64位系统是2048；poll和epoll都使用链表的方式，大小理论上没有限制；



## Reactor/Proactor

### Reactor

1. 也叫反应器；
2. 大致思路是，用户为fd注册所关心的事件，例如可读事件，可写事件；
3. 然后Reactor进行事件轮询，有任何fd的任何事件发生时，就调用用户所设置的对应的处理方法；
4. 用户的处理方法开始进行读、写等操作；

### Proactor

1. 也叫前摄式，或者主动器；
2. 大致思路是，用户为fd发起对应的操作，例如读操作，或者写操作；
3. 每个操作都是异步的，对应的每个操作都有一个完成后的回调；
4. 然后Proactor管理完成事件队列，并分发这些完成事件，也就是调用用户的回调；

### 总结

1. 被动和主动：Reactor是被动的，在状态就绪时进行对应的操作；Proactor是主动的，主动发起操作，在就绪并操作完成后，处理最终的完成回调；
2. 串行和并发：Reactor在一个反应器内，所有操作都是串行的，例如一个Reactor内监听了多个fd的多个事件，则所有fd的所有事件都是串行也就是同步的响应的；Proactor则可以异步也就是并发的发起多个fd的多个操作，然后每个fd的每个操作完成事件都单独响应；
3. 简单和复杂：Reactor的事件处理可以理解为单线程顺序执行的，不用考虑并发加锁等问题，Proactor由于响应是异步的，处理要相对复杂一些；
4. 时间和性能：Reactor的在事件响应操作时不能耗时太长，否则会影响其它fd和事件的响应，Proactor由于是异步的，可以处理耗时较长的任务；

### 再次总结

1. Reactor和Proactor只是一种IO设计模式，注意是软件设计模式，与操作系统提供的IO处理方式是没有直接联系的；
2. 例如，libevent框架、libuv框架，使用Reactor模式，使用了操作系统的select/poll机制，在linux下也使用了epoll，而在windows下，也有针对iocp的实现；
3. 例如，ACE框架，提供了Reactor模式，也提供了Proactor模式；
4. 例如，ASIO框架，使用Proactor模式，但在linux下使用epoll来包装，而windows下则使用IOCP；
5. 所以，针对不同的操作系统提供的IO机制，都可以进行Reactor或者Proactor模式的设计，比如ACE，使用Reactor或者Proactor模式的时候，不用关心ACE内部是如何实现的，而ACE可以利用不同的操作系统下最优的IO机制；
6. 前述总结的Reactor或者Proactor的优缺点和不同，并不是绝对的，比如，“Reactor的在事件响应操作时不能耗时太长，否则会影响其它fd和事件的响应”，实际场景中可能在读事件到达后，进行数据读取，然后放入另一个逻辑线程中进行后续处理；
7. 所以，两种设计模式的采用是需要根据实际场景，进行复杂度和性能的综合权衡；
8. 同理，要直接调用系统提供的IO机制的API，例如select/poll/epoll/iocp，还是要采用一些网络框架，例如libevent，libuv，ACE，也取决于复杂度、性能、场景的考量；

