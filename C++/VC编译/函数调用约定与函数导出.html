<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数调用约定与函数导出 | Lindorof</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="Lindorof's Blog">
    <link rel="preload" href="/assets/css/0.styles.8ac2847d.css" as="style"><link rel="preload" href="/assets/js/app.b639eb72.js" as="script"><link rel="preload" href="/assets/js/2.5df156af.js" as="script"><link rel="preload" href="/assets/js/5.339eb2f5.js" as="script"><link rel="prefetch" href="/assets/js/10.ee4568ff.js"><link rel="prefetch" href="/assets/js/11.8db0767a.js"><link rel="prefetch" href="/assets/js/12.92a4e660.js"><link rel="prefetch" href="/assets/js/13.e2450b62.js"><link rel="prefetch" href="/assets/js/14.5ae14743.js"><link rel="prefetch" href="/assets/js/15.62a967cf.js"><link rel="prefetch" href="/assets/js/16.3482df63.js"><link rel="prefetch" href="/assets/js/17.881a9d91.js"><link rel="prefetch" href="/assets/js/18.d6e19ee5.js"><link rel="prefetch" href="/assets/js/19.caf0829a.js"><link rel="prefetch" href="/assets/js/20.a80e123c.js"><link rel="prefetch" href="/assets/js/21.9c810086.js"><link rel="prefetch" href="/assets/js/22.bc5f69cb.js"><link rel="prefetch" href="/assets/js/23.f15ef55d.js"><link rel="prefetch" href="/assets/js/24.b8714e3e.js"><link rel="prefetch" href="/assets/js/25.d673c092.js"><link rel="prefetch" href="/assets/js/26.28d57b84.js"><link rel="prefetch" href="/assets/js/27.d8b15b76.js"><link rel="prefetch" href="/assets/js/28.2574be13.js"><link rel="prefetch" href="/assets/js/29.54667d47.js"><link rel="prefetch" href="/assets/js/3.f6602695.js"><link rel="prefetch" href="/assets/js/30.dd697263.js"><link rel="prefetch" href="/assets/js/31.aafbc8db.js"><link rel="prefetch" href="/assets/js/32.5fe2531d.js"><link rel="prefetch" href="/assets/js/33.c3dfca3c.js"><link rel="prefetch" href="/assets/js/34.22613e38.js"><link rel="prefetch" href="/assets/js/35.aad9af2b.js"><link rel="prefetch" href="/assets/js/36.badbd522.js"><link rel="prefetch" href="/assets/js/37.45905373.js"><link rel="prefetch" href="/assets/js/38.ab0de43e.js"><link rel="prefetch" href="/assets/js/39.d1a7492c.js"><link rel="prefetch" href="/assets/js/4.c7710dca.js"><link rel="prefetch" href="/assets/js/40.92c4cb14.js"><link rel="prefetch" href="/assets/js/41.cc19be50.js"><link rel="prefetch" href="/assets/js/42.c9b4b585.js"><link rel="prefetch" href="/assets/js/43.1af966c8.js"><link rel="prefetch" href="/assets/js/44.40ebac1c.js"><link rel="prefetch" href="/assets/js/45.469b8553.js"><link rel="prefetch" href="/assets/js/46.eb491d21.js"><link rel="prefetch" href="/assets/js/47.03d1fbf2.js"><link rel="prefetch" href="/assets/js/48.af296c16.js"><link rel="prefetch" href="/assets/js/49.3a42b55b.js"><link rel="prefetch" href="/assets/js/50.ef35a161.js"><link rel="prefetch" href="/assets/js/51.284d50de.js"><link rel="prefetch" href="/assets/js/52.c4983004.js"><link rel="prefetch" href="/assets/js/53.83c193e1.js"><link rel="prefetch" href="/assets/js/54.08f26cd6.js"><link rel="prefetch" href="/assets/js/55.ef20313b.js"><link rel="prefetch" href="/assets/js/56.dc2772cf.js"><link rel="prefetch" href="/assets/js/57.add26447.js"><link rel="prefetch" href="/assets/js/58.ff8f2704.js"><link rel="prefetch" href="/assets/js/59.43fdbc04.js"><link rel="prefetch" href="/assets/js/6.0ce72a94.js"><link rel="prefetch" href="/assets/js/60.1a27c7c3.js"><link rel="prefetch" href="/assets/js/61.9ca63ff6.js"><link rel="prefetch" href="/assets/js/62.9ab09b12.js"><link rel="prefetch" href="/assets/js/63.a6b6d595.js"><link rel="prefetch" href="/assets/js/64.5e9ac56b.js"><link rel="prefetch" href="/assets/js/65.bcfb6015.js"><link rel="prefetch" href="/assets/js/66.5024eb22.js"><link rel="prefetch" href="/assets/js/67.5d83f99f.js"><link rel="prefetch" href="/assets/js/68.80f05874.js"><link rel="prefetch" href="/assets/js/69.6f9ff293.js"><link rel="prefetch" href="/assets/js/7.726c7fbf.js"><link rel="prefetch" href="/assets/js/70.92b749fb.js"><link rel="prefetch" href="/assets/js/71.a4248217.js"><link rel="prefetch" href="/assets/js/72.29aeb940.js"><link rel="prefetch" href="/assets/js/73.8918e90b.js"><link rel="prefetch" href="/assets/js/74.81fd32da.js"><link rel="prefetch" href="/assets/js/75.5357ccc2.js"><link rel="prefetch" href="/assets/js/76.66fc1725.js"><link rel="prefetch" href="/assets/js/77.6f29512b.js"><link rel="prefetch" href="/assets/js/78.a63871cd.js"><link rel="prefetch" href="/assets/js/79.c646997c.js"><link rel="prefetch" href="/assets/js/8.81d630fc.js"><link rel="prefetch" href="/assets/js/80.b5d5ad39.js"><link rel="prefetch" href="/assets/js/81.601aa569.js"><link rel="prefetch" href="/assets/js/82.99bc0640.js"><link rel="prefetch" href="/assets/js/83.06d4defc.js"><link rel="prefetch" href="/assets/js/84.44856307.js"><link rel="prefetch" href="/assets/js/85.3b88ee80.js"><link rel="prefetch" href="/assets/js/86.47c806cb.js"><link rel="prefetch" href="/assets/js/87.b5201cdf.js"><link rel="prefetch" href="/assets/js/88.f9ce8655.js"><link rel="prefetch" href="/assets/js/89.c1f12bf1.js"><link rel="prefetch" href="/assets/js/9.b6118830.js"><link rel="prefetch" href="/assets/js/90.e0f850a2.js"><link rel="prefetch" href="/assets/js/91.8166ca11.js"><link rel="prefetch" href="/assets/js/92.6ba6ce27.js"><link rel="prefetch" href="/assets/js/93.6e09fb58.js"><link rel="prefetch" href="/assets/js/94.1b324565.js"><link rel="prefetch" href="/assets/js/95.5308659f.js"><link rel="prefetch" href="/assets/js/96.306bee11.js"><link rel="prefetch" href="/assets/js/97.6e231fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ac2847d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Lindorof" class="logo"> <span class="site-name can-hide">Lindorof</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>函数调用约定与函数导出</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#调用约定-概述" class="sidebar-link">调用约定 - 概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#调用约定-对函数栈区的影响" class="sidebar-link">调用约定 - 对函数栈区的影响</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#cdecl" class="sidebar-link">__cdecl</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#stdcall" class="sidebar-link">__stdcall</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#fastcall" class="sidebar-link">__fastcall</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#thiscall" class="sidebar-link">__thiscall</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#调用约定-对函数名称修饰的影响-c编译器" class="sidebar-link">调用约定 - 对函数名称修饰的影响 - C编译器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#cdecl-2" class="sidebar-link">__cdecl</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#stdcall-2" class="sidebar-link">__stdcall</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#fastcall-2" class="sidebar-link">__fastcall</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#调用约定-对函数名称修饰的影响-c-编译器" class="sidebar-link">调用约定 - 对函数名称修饰的影响 - C++编译器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#规则" class="sidebar-link">规则</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#函数名" class="sidebar-link">函数名</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#调用约定标识" class="sidebar-link">调用约定标识</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#参数表" class="sidebar-link">参数表</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#结束符" class="sidebar-link">结束符</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#举例" class="sidebar-link">举例</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#c-c-混合编程" class="sidebar-link">C &amp; C++ 混合编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#问题描述" class="sidebar-link">问题描述</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#extern-c" class="sidebar-link">extern &quot;C&quot;</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#cplusplus" class="sidebar-link">__cplusplus</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#函数的导出-概述" class="sidebar-link">函数的导出 - 概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#函数的导出-编译时" class="sidebar-link">函数的导出 - 编译时</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#要素" class="sidebar-link">要素</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#原理" class="sidebar-link">原理</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#函数的导出-运行时" class="sidebar-link">函数的导出 - 运行时</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#原理-2" class="sidebar-link">原理</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导出-declspec-dllexport" class="sidebar-link">导出 - __declspec(dllexport)</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导出-def模块文件" class="sidebar-link">导出 - .def模块文件</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导入-静态加载" class="sidebar-link">导入 - 静态加载</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导入-静态加载-declspec-dllimport" class="sidebar-link">导入 - 静态加载 - __declspec(dllimport)</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导入-动态加载" class="sidebar-link">导入 - 动态加载</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#导入-动态加载-获取函数" class="sidebar-link">导入 - 动态加载 - 获取函数</a></li></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#附记" class="sidebar-link">附记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#查看导出函数" class="sidebar-link">查看导出函数</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#从-dll-提取-lib" class="sidebar-link">从 DLL 提取 LIB</a></li><li class="sidebar-sub-header"><a href="/C++/VC%E7%BC%96%E8%AF%91/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%BC%E5%87%BA.html#dll-forward-技术" class="sidebar-link">DLL FORWARD 技术</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="函数调用约定与函数导出"><a href="#函数调用约定与函数导出" class="header-anchor">#</a> 函数调用约定与函数导出</h1> <p><em>本文分为两大部分，「调用约定」和「函数导出」，然后在末尾对一些话题进行较浅的拓展。</em></p> <h2 id="调用约定-概述"><a href="#调用约定-概述" class="header-anchor">#</a> 调用约定 - 概述</h2> <p>我们熟知的函数由几个部分组成：</p> <ol><li>返回值类型；</li> <li>函数名称；</li> <li>参数（参数类型和个数）；</li></ol> <p>而事实上，函数还有一个很重要的组成部分：<em><strong>调用约定</strong></em> ，也就是对函数调用的约束和规定，它决定了以下内容：</p> <ol><li>函数参数的压栈顺序；</li> <li>由调用者还是被调用者进行函数栈的清理；</li> <li>对函数名称的修饰方式；</li></ol> <p>常见的函数调用约定有：</p> <ol><li>__cdecl</li> <li>__stdcall</li> <li>__fastcall</li> <li>__thiscall</li></ol> <blockquote><p>备注：</p> <ul><li>VC中常见的一些宏例如“WINAPI”、&quot;CALLBACK&quot;，其实就是__stdcall；</li> <li>从调用约定所影响的内容来看，主要是两大方面：<em><strong>函数栈区的影响</strong></em>、<em><strong>函数名称修饰的影响</strong></em> ；</li></ul></blockquote> <h2 id="调用约定-对函数栈区的影响"><a href="#调用约定-对函数栈区的影响" class="header-anchor">#</a> 调用约定 - 对函数栈区的影响</h2> <h3 id="cdecl"><a href="#cdecl" class="header-anchor">#</a> __cdecl</h3> <ol><li>C/C++默认的调用约定；</li> <li>函数参数 <em><strong>从右到左</strong></em> 入栈；</li> <li>函数调用结束后，由 <em><strong>调用者</strong></em> 进行栈区的清理；</li> <li>问题：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清理栈区不可行；</li> <li>问题：每次调用都包含清理栈区的代码，故可执行文件较大；</li> <li>优点：像 printf 这种具有可变参的函数，只有调用者知道实际参数是多少个，决定了这种函数只能使用这种调用约定；</li></ol> <h3 id="stdcall"><a href="#stdcall" class="header-anchor">#</a> __stdcall</h3> <ol><li>Windows API默认的调用约定；</li> <li>函数参数 <em><strong>从右到左</strong></em> 入栈；</li> <li>函数调用结束后，由 <em><strong>被调用者</strong></em> 进行栈区的清理；</li></ol> <h3 id="fastcall"><a href="#fastcall" class="header-anchor">#</a> __fastcall</h3> <ol><li>适用于对性能要求较高的场合；</li> <li><em><strong>从左开始不大于4字节</strong></em> 的参数放入CPU的ECX和EDX寄存器，其余参数 <em><strong>从右向左</strong></em> 入栈；</li> <li>函数调用结束后，由 <em><strong>被调用者</strong></em> 进行栈区的清理；</li> <li>优点：如果参数不大于4字节，则这种调用约定可提高性能；</li></ol> <h3 id="thiscall"><a href="#thiscall" class="header-anchor">#</a> __thiscall</h3> <ol><li>C++类成员函数缺省的调用约定，不需要也不能显式声明；</li> <li>因为C++类成员函数的调用会自动传入 this 这个指针参数；</li> <li>函数参数：<em><strong>从右到左</strong></em> 入栈；</li> <li>this 指针参数：
<ul><li>若参数个数确定，则通过ECX传递给被调用者；</li> <li>若参数个数不确定，则在所有参数入栈后再被压入栈；</li></ul></li> <li>栈区清理：
<ul><li>若参数个数确定，则 <em><strong>被调用者</strong></em> 清理；</li> <li>若参数个数不确定，则 <em><strong>调用者</strong></em> 清理；</li></ul></li></ol> <h2 id="调用约定-对函数名称修饰的影响-c编译器"><a href="#调用约定-对函数名称修饰的影响-c编译器" class="header-anchor">#</a> 调用约定 - 对函数名称修饰的影响 - C编译器</h2> <h3 id="cdecl-2"><a href="#cdecl-2" class="header-anchor">#</a> __cdecl</h3> <ul><li>规则：一个下划线前缀，函数名；</li> <li>格式：_FunctionName；</li> <li>例如：void Input(int a, int b) 被修饰为 _Input；</li></ul> <h3 id="stdcall-2"><a href="#stdcall-2" class="header-anchor">#</a> __stdcall</h3> <ul><li>规则：一个下划线前缀，函数名，一个@符号，参数的字节数；</li> <li>格式：_FunctionName@Number；</li> <li>例如：void Input(int a, int b) 被修饰为 _Input@8；</li></ul> <h3 id="fastcall-2"><a href="#fastcall-2" class="header-anchor">#</a> __fastcall</h3> <ul><li>规则：一个@符号前缀，函数名，一个@符号，参数的字节数；</li> <li>格式：@FunctionName@Number；</li> <li>例如：void Input(int a, int b) 被修饰为 @Input@8；</li></ul> <h2 id="调用约定-对函数名称修饰的影响-c-编译器"><a href="#调用约定-对函数名称修饰的影响-c-编译器" class="header-anchor">#</a> 调用约定 - 对函数名称修饰的影响 - C++编译器</h2> <h3 id="规则"><a href="#规则" class="header-anchor">#</a> 规则</h3> <ol><li>一个 ? 符号前缀</li> <li>函数名；</li> <li>两个@符号，调用约定标识；</li> <li>参数表；</li> <li>结束符；</li></ol> <h3 id="函数名"><a href="#函数名" class="header-anchor">#</a> 函数名</h3> <ul><li>非类成员函数：函数名；</li> <li>类成员函数：函数名，一个@符号，类名；</li></ul> <h3 id="调用约定标识"><a href="#调用约定标识" class="header-anchor">#</a> 调用约定标识</h3> <ul><li>__stdcall：YG；</li> <li>__cdecl：YA；</li> <li>__fastcall：YI；</li> <li>__thiscall：QAE(public)，IAE(protected)，AAE(private)；</li> <li>__thiscall const：QBE(public)，IBE(protected)，ABE(private)；</li></ul> <h3 id="参数表"><a href="#参数表" class="header-anchor">#</a> 参数表</h3> <blockquote><p>首先说明：参数表中第一个是返回值，第二个开始才是函数参数：</p></blockquote> <ul><li>X：void</li> <li>D：char</li> <li>E：unsigned char</li> <li>F：short</li> <li>H：int</li> <li>I：unsigned int</li> <li>J：long</li> <li>K：unsigned long</li> <li>M：float</li> <li>N：double</li> <li>_N：bool</li> <li>U：结构类型，后面跟上结构体名称，用“@@”表示名称结束</li> <li>PA：指针，后面跟上指针类型，若相同类型指针连续出现，以“0”代替，一个“0”代表一次重复</li> <li>PB：const 指针，与PA一致</li> <li>AAV1：该类实例的引用</li> <li>ABV1：该类实例的 const 引用</li></ul> <h3 id="结束符"><a href="#结束符" class="header-anchor">#</a> 结束符</h3> <ul><li><code>@Z</code> 标识整个名字的结束</li> <li>如果该函数无参数，则以 <code>XZ</code> 标识结束；</li></ul> <h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h3> <p>例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">/*
?Test1@@YGHPADK@Z
*/</span>
<span class="token keyword">int</span> __stdcall <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> var1<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ulP<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">/*
?Test2@@YAXXZ
*/</span>
<span class="token keyword">void</span> __cdecl <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>例如类方法：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">CTest</span> 
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span> 
    <span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">protected</span><span class="token operator">:</span> 
    <span class="token keyword">void</span> <span class="token function">CopyInfo</span><span class="token punctuation">(</span><span class="token keyword">const</span> CTest <span class="token operator">&amp;</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token function">DrawText</span><span class="token punctuation">(</span>HDC hdc<span class="token punctuation">,</span> <span class="token keyword">long</span> pos<span class="token punctuation">,</span> <span class="token keyword">const</span> TCHAR<span class="token operator">*</span> text<span class="token punctuation">,</span> RGBQUAD color<span class="token punctuation">,</span> BYTE bUnder<span class="token punctuation">,</span> <span class="token keyword">bool</span> bSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">InsightClass</span><span class="token punctuation">(</span>DWORD dwClass<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>Function：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">?</span>Function@CTest@@AAEXH@Z
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>CopyInfo：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">?</span>CopyInfo@CTest@@IAEXABV1@@Z
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>DrawText：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">/*
TCHAR其实是char 
BYTE其实是unsigned char 
HDC其实是HDC结构类型的指针 
RGBQUAD其实是结构体tagRGBQUAD 
*/</span>
<span class="token operator">?</span>DrawText@CTest@@QAEJPAUHDC@@JPBDUtagRGBQUAD@@E_N@Z
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>InsightClass：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">/*
DWORD其实是unsigned long 
*/</span>
<span class="token operator">?</span>InsightClass@CTest@@QBEJK@Z
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="c-c-混合编程"><a href="#c-c-混合编程" class="header-anchor">#</a> C &amp; C++ 混合编程</h2> <h3 id="问题描述"><a href="#问题描述" class="header-anchor">#</a> 问题描述</h3> <p>从前面讲的内容可以看到：</p> <ol><li>调用约定对函数栈区会产生影响，但是， 这个影响与C/C++编译器是无关的；</li> <li>调用约定对函数名称修饰会产生影响，而且，C/C++编译器的规则是不一样的；</li></ol> <p>而C/C++混合编程的时候，问题是：</p> <ul><li>假设C程序中提供了一个方法，该方法使用C编译器编译（可能C程序通过.o/.obj文件输出并进行后期link，或者通过LIB/DLL等形式输出）</li> <li>然后在C++程序中需要使用该方法，且C++程序使用C++编译器编译</li> <li>那么，在保证了二者的调用约定一致的情况下，仍然会出现C++编译器找不到该方法实现体的问题</li></ul> <p>原因很好理解：</p> <ul><li>因为C/C++编译器使用了不同的函数名称修饰</li> <li>而要解决这个问题，就是让C++编译器使用C编译器的函数名称修饰方式</li> <li>也就是 <code>extern &quot;C&quot;</code></li></ul> <h3 id="extern-c"><a href="#extern-c" class="header-anchor">#</a> extern &quot;C&quot;</h3> <blockquote><p><code>extern &quot;C&quot;</code> 这句话的作用，就是要求统一使用C编译器的方式，来进行函数名称的修饰。</p></blockquote> <p>例如，在C程序中该方法如下：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> __stdcall <span class="token function">funC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那么，在C++程序中，要使用该C方法之前，先进行声明（至于为何还要再加一个extern，那是C的知识，与本文无关）：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">void</span> <span class="token keyword">extern</span> __stdcall <span class="token function">funC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果要使用的C方法比较多，则可以如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> <span class="token keyword">extern</span> stdcall <span class="token function">funC1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token keyword">extern</span> stdcall <span class="token function">funC2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token keyword">extern</span> __stdcall <span class="token function">funC3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>然后，在C++程序中，就可以直接使用该C方法了：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br><br></div><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">CTest</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">funC3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="cplusplus"><a href="#cplusplus" class="header-anchor">#</a> __cplusplus</h3> <blockquote><p><code>__cplusplus</code> 这个宏是 CPP 文件自带的，其作用如下：</p></blockquote> <ul><li>只有 C++ 才提供 <code>extern &quot;C&quot;</code> 这个符号，C编译器是不认识这个符号的</li> <li>也就是说，如果是C++编译器，才认识 <code>extern &quot;C&quot;</code> 这个符号</li> <li>因为，C程序可能将方法统一声明在一个 .H 中，并提供给不同的使用者使用，而使用者可能是C程序，也可能是C++程序</li> <li>因此，就需要做一个判断，如果是C++程序，那就加上 <code>extern &quot;C&quot;</code> ，如果不是C++程序，那就不用加上 <code>extern &quot;C&quot;</code> 了，否则C编译器不认识该符号</li></ul> <blockquote><p>因此，我们就可以将对外提供的方法统一定义在一个.H文件中，如下：</p></blockquote> <div class="language-c line-numbers-mode"><div class="highlight-lines"><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">int</span> <span class="token keyword">extern</span> __stdcall <span class="token function">funC1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token keyword">extern</span> __stdcall <span class="token function">funC2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token keyword">extern</span> __stdcall <span class="token function">funC3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="函数的导出-概述"><a href="#函数的导出-概述" class="header-anchor">#</a> 函数的导出 - 概述</h2> <p>函数导出的目的，是为了提供给使用者使用，因此需注意几点：</p> <ol><li>调用约定会对 <em><strong>函数栈区</strong></em> 产生影响，只有调用者和被调用者都使用同样的约定，才能保证程序正常的运行</li> <li>调用约定会对 <em><strong>函数名称</strong></em> 产生影响，且不同的编译器对函数名称的修饰是不同的</li></ol> <p>因此，对于 <em><strong>调用者和被调用者</strong></em> ，要注意：</p> <ol><li>都需要使用相同的 <em><strong>调用约定</strong></em></li> <li>确保使用相同编译器的 <em><strong>函数名修饰方式</strong></em></li></ol> <blockquote><p>因此，在上述关于C/C++混合编程一节中已经讲得很清晰了：从通用和严谨的角度来说，若涉及到函数的导出与共享，则 <code>extern &quot;C&quot;</code> 和 <code>__cplusplus</code> 都是必须使用的</p></blockquote> <p>函数导出的本质可以理解为一种 <em><strong>分工</strong></em> ，也就是说：</p> <ul><li>调用者需要使用某个函数</li> <li>而这个函数的实现由提供者来完成</li> <li>因此，函数导出也可以理解为函数体（函数实现）的一种共享</li></ul> <p>因此，根据这个理解，可以将函数导出分为几类：</p> <ol><li><em><strong>编译时</strong></em> ，也就是编译期间就得到了函数体，并包含在使用者程序内，函数体属于使用者程序的一部分；例如 <code>.lib</code> , <code>.obj</code> 等；</li> <li><em><strong>运行时</strong></em> ，也就是运行期间才获取或加载函数体，函数体与使用者是独立的两个模块；例如 <code>.dll</code> , <code>.exe</code> 等；因此，调用者在使用这些导出函数时，又分为 <em><strong>静态加载</strong></em> 和 <em><strong>动态加载</strong></em> ；</li></ol> <h2 id="函数的导出-编译时"><a href="#函数的导出-编译时" class="header-anchor">#</a> 函数的导出 - 编译时</h2> <h3 id="要素"><a href="#要素" class="header-anchor">#</a> 要素</h3> <p>编译时的函数导出与使用比较简单：</p> <ol><li>提供者，<code>.h</code> ，用来声明函数；</li> <li>提供者，<code>.c/.cpp</code> ，用来实现函数；</li> <li>提供者，编译为<code>.lib/.obj</code> 等；</li> <li>使用者，引入 <code>.h</code> 及 <code>.lib</code> ，即可直接使用函数；</li></ol> <p>例如，头文件 <code>a.h</code> 声明如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">void</span> __stdcall <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>对应的，函数体 <code>a.cpp</code> 实现如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> __stdcall <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>编译之后：</p> <ul><li>可能编译为 <code>.lib</code> ，或者 <code>.obj</code> 等</li> <li>因此，将头文件，编译后的函数体，交给调用者即可；</li></ul> <p>而调用者则可直接使用如下：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><div class="highlighted"> </div><div class="highlighted"> </div><br><br><div class="highlighted"> </div><br><br></div><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;a.h&quot;</span></span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> comment (lib, &quot;a.lib&quot;)</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>在该过程中，提供者、调用者、编译器的工作，可用下图来表示：</p> <p><img src="/assets/img/01.953ee518.jpg" alt="pic"></p> <p>根据上图进行总结，要点如下：</p> <ol><li>对于提供者和调用者来说，头文件都遵循了统一的 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> 规则；</li> <li>对于提供者和调用者来说，只需要关心头文件中的函数名称即可；</li> <li>对于编译器来说，都根据头文件中的调用约定和函数名称，进行了函数名的修饰，但是这个修饰对于提供者和调用者来说是透明的；</li></ol> <p>结合上图，看函数名称的变化：</p> <ol><li>头文件中声明函数名是 <code>func</code> ；</li> <li>函数实现时实现为 <code>func</code> ；</li> <li>函数体 <code>func</code> 被编译为 <code>_func@4</code> ；</li> <li>调用者代码中根据头文件的名称直接调用 <code>func</code> ；</li> <li>调用者代码中的 <code>func</code> 被编译为 <code>_func@4</code> ；</li> <li>因此，提供者和调用者在程序中都统一使用 <code>func</code> ；</li> <li>但是，提供者和调用者在编译后都统一使用了 <code>_func@4</code> ，编译器能够正常完成链接和编译；</li></ol> <h2 id="函数的导出-运行时"><a href="#函数的导出-运行时" class="header-anchor">#</a> 函数的导出 - 运行时</h2> <h3 id="原理-2"><a href="#原理-2" class="header-anchor">#</a> 原理</h3> <p>运行时的函数导出与使用包括如下要素：</p> <ol><li>提供者，<code>.h</code> ，用来声明导出函数；</li> <li>提供者，<code>.c/.cpp</code> ，用来实现函数；</li> <li>提供者，编译为 <code>.dll</code> 及对应的 <code>.lib</code> ；</li> <li>使用者，引入 <code>.h</code> 及 <code>.lib</code> ，即可直接使用函数，即 <em><strong>静态加载</strong></em> ；也可只使用 <code>.dll</code> 或 <code>.exe</code> ，即 <em><strong>动态加载</strong></em> ；</li></ol> <p>过程可用下图来表示：</p> <p><img src="/assets/img/02.9e24b22e.jpg" alt="pic"></p> <p>从上图可以看到：</p> <ol><li>导出涉及到一些语法，且上图只是其中一种语法，后续会讲解各种导出方式；</li> <li>导出后可以得到 <code>.lib</code> ，<code>.dll</code> ；</li> <li>对于 <code>.lib</code> 来说，函数名称修饰遵循前面所总结的规则，即 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> ；</li> <li>对于 <code>.dll</code> 来说，函数名称可以有多种形态，后续会分别讲解；</li></ol> <p>需要注意的是，「运行时」函数导出与前面所讲的「编译时」函数导出虽然都有 <code>.lib</code> ，但其实区别很大的：</p> <ul><li>「编译时」的函数导出，<code>.lib</code> 中包含了函数体；</li> <li>「运行时」的函数导出，<code>.lib</code> 中只是包含了函数在 <code>.dll/.exe</code> 中的名称和地址等信息，函数体在 <code>.dll/.exe</code> 中；</li></ul> <h3 id="导出-declspec-dllexport"><a href="#导出-declspec-dllexport" class="header-anchor">#</a> 导出 - __declspec(dllexport)</h3> <blockquote><p>这是一种在DLL中导出函数的方式，使用 <code>__declspec(dllexport)</code> 语法。</p></blockquote> <ul><li>注意，目的只是为了DLL函数的导出，而其中涉及到 <code>.dll</code> 和 <code>.lib</code></li> <li>对于 <code>.lib</code> 来说，函数名称遵循 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em></li> <li>但对于 <code>.dll</code> 来说，函数名称有几种情况：
<ul><li>第一种情况：
<ul><li>使用C/C++默认的调用约定，即 <code>__cdecl</code> ，由于是默认的，可以不用显式声明；</li> <li>使用C编译器的名称修饰方式，即 <code>extern &quot;C&quot;</code> ；</li> <li>在这种情况下，<code>.dll</code> 中的函数名称就不会进行额外修饰；</li></ul></li> <li>第二种情况：
<ul><li>即不满足第一种情况的任何一种形式；</li> <li>此时 .dll 中的函数名称修饰由调用约定和编译器决定；</li></ul></li></ul></li></ul> <p>举例：<code>.dll</code> 中的函数名称是 <code>func</code>；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>举例：<code>.dll</code> 中的函数名称是 <code>func</code> ；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> __cdecl <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>举例：<code>.dll</code> 中的函数名称是 <code>_func@4</code> ；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> __stdcall <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>举例：在C++编译器中，<code>.dll</code> 中的函数名称是 <code>?Test1@@YGHPADK@Z</code> ；</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">int</span> __stdcall <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> var1<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ulP<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="导出-def模块文件"><a href="#导出-def模块文件" class="header-anchor">#</a> 导出 - .def模块文件</h3> <blockquote><p>这是另一种导出DLL函数的方式，使用 <code>.def</code> 模块文件；一样的，目的只是为了DLL函数的导出，而其中涉及到 <code>.dll</code> 和 <code>.lib</code> 。</p></blockquote> <ol><li>对于 <code>.lib</code> 来说，函数名称遵循 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> ；</li> <li>对于 <code>.dll</code> 来说，使用 <code>.def</code> 导出的DLL函数名称不会进行额外修饰；</li></ol> <p>因此，头文件 <code>a.h</code> 声明如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">void</span> __stdcall <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> __stdcall <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>对应的，<code>.def</code> 文件如下定义：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br></div><pre class="language-cpp"><code>LIBRARY <span class="token string">&quot;DllName&quot;</span>
EXPORTS
func1 @<span class="token number">1</span> NONAME 
funcX <span class="token operator">=</span> func2 @<span class="token number">2</span> NONAME
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>.def</code> 文件说明如下：</p> <ul><li><code>LIBRARY</code> ，声明DLL库的名称；</li> <li><code>EXPORTS</code> ，开始声明要导出的函数；</li></ul> <p>要导出的函数格式：<code>函数别名 = 函数名 @ 序号 [NONAME]</code></p> <ul><li><code>函数别名</code> ，就是给所导出的函数进行重命名，若不重命名，则导出为函数名；</li> <li><code>函数名</code> ，就是所要导出的函数名；</li> <li><code>序号</code> ，使用者可根据序号来获取函数；</li> <li><code>NONAME</code> ，可选，DLL中不包含函数名，只包含序号，减小DLL的体积；</li></ul> <h3 id="导入-静态加载"><a href="#导入-静态加载" class="header-anchor">#</a> 导入 - 静态加载</h3> <p>静态加载时：</p> <ul><li>直接使用 <code>.lib</code> 和 <code>.h</code> 即可</li> <li>但仍然要注意的是，既然使用到 <code>.h</code> ，那么就必须保持一致的 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> 。</li></ul> <p>例如，头文件 <code>a.h</code> 声明如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token keyword">void</span> __stdcall <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>而调用者则可直接使用如下：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><div class="highlighted"> </div><br><br></div><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&quot;a.h&quot;</span></span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> comment (lib,&quot;a.lib&quot;)</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>静态加载的原理可通过下图来看：</p> <p><img src="/assets/img/03.36af45f2.jpg" alt="pic"></p> <p>从图中可以看到：</p> <ol><li>静态加载时，使用者只需要关注与提供者保持一致的 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> ，这通过 <code>.h</code> 文件即可完成约定；</li> <li>使用者不用关注在 <code>.dll</code> 中的真正函数名称是什么，因为 <code>.lib</code> 知道 <code>.dll</code> 中的真正函数名和地址；</li></ol> <h3 id="导入-静态加载-declspec-dllimport"><a href="#导入-静态加载-declspec-dllimport" class="header-anchor">#</a> 导入 - 静态加载 - __declspec(dllimport)</h3> <blockquote><p>这是一种静态加载DLL中函数的方式，使用语法 <code>__declspec(dllimport)</code> 。注意，目的只是为了DLL函数的导入，且不用该修饰也能正常导入，但是存在一些细微的区别：</p></blockquote> <ol><li>不使用该修饰时，编译器不知道该函数是从DLL中导入的，因此会产生一次 <em><strong>JMP</strong></em> 行为；</li> <li>使用该修饰时，编译器知道该函数是从DLL中导入的，因此可以直接 <em><strong>CALL</strong></em> 对应的函数地址；</li> <li>这涉及到编译原理和运行EXE时的PE文件格式，我也不全懂；</li></ol> <p>因此，针对DLL提供者的 <code>.h</code> 文件，我们就可以如下声明，也是我们平时最常看到的形式：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> XXXX</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYEXPORT __declspec(dllexport)</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYEXPORT __declspec(dllimport)</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

MYEXPORT <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>其中：</p> <ul><li><code>XXXX</code> 是一个宏；</li> <li>对于 <em><strong>提供者</strong></em> 来说，代码环境中会定义该宏，从而就是 <em><strong>导出</strong></em> 函数；</li> <li>对于 <em><strong>使用者</strong></em> 来说，代码环境中未定义该宏，从而就是 <em><strong>导入</strong></em> 函数；</li></ul> <h3 id="导入-动态加载"><a href="#导入-动态加载" class="header-anchor">#</a> 导入 - 动态加载</h3> <p>动态加载时：</p> <ul><li>就不需要使用 <code>.lib</code> 和 <code>.h</code></li> <li>因此此时只关注DLL中的函数</li> <li>所以，此时要关注的是与 <em><strong>提供者</strong></em> 保持一致的 <em><strong>调用约定</strong></em>，而 <em><strong>函数名称</strong></em> 则使用DLL中的函数名</li></ul> <p>动态加载的原理通过下图来看：</p> <p><img src="/assets/img/04.b2f8637a.jpg" alt="pic"></p> <p>对于使用者来说：</p> <ol><li><em><strong>调用约定</strong></em> 必须与DLL中的函数保持一致；</li> <li><em><strong>函数名称</strong></em> 必须使用DLL中的实际函数名称；</li></ol> <h3 id="导入-动态加载-获取函数"><a href="#导入-动态加载-获取函数" class="header-anchor">#</a> 导入 - 动态加载 - 获取函数</h3> <p>动态加载时，获取函数有多种方式：</p> <blockquote><p>根据名称获取</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token string">&quot;funcXXX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>说明：</p> <ul><li><code>funcXXX</code> 就是DLL中实际的函数名称；</li> <li>前提是，DLL导出函数时包含了函数名；</li></ul> <blockquote><p>根据序号获取</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token function">MAKEINTRESOURCE</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>说明：</p> <ul><li><code>MAKEINTRESOURCE</code> 就是根据序号来得到函数；</li> <li>序号必须与DLL导出函数时的序号对应；</li> <li>前提是，DLL导出函数时指定了序号；</li> <li>如果DLL导出函数使用了 <code>NONAME</code> ，则只能根据序号来获取；</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <blockquote><p>函数的导出目的就是为了 <em><strong>共享</strong></em> ，因此，涉及到一致的 <em><strong>函数调用约定</strong></em> 和 <em><strong>编译器函数名称修饰</strong></em> 。</p></blockquote> <p>而要共享函数，会涉及到 <code>.h</code> 文件的定义，所以：</p> <ul><li>调用约定 <em><strong>默认</strong></em> 是 <code>__cdecl</code> ，使用其它调用约定则显式的写明，例如 <code>__stdcall</code> ；</li> <li>函数名称修饰最好都指定C方式，即 <code>extern &quot;C&quot;</code> ；</li> <li>为了适应C/C++编译器，再增加 <code>__cplusplus</code> 判断；</li> <li>针对「运行时」的函数导出，可使用 <code>__declspec(export)</code> 或者 <code>.def</code> ；</li> <li>针对「运行时」的函数导入，若提供者使用了 <code>__declspec(export)</code> ，则导入时最好使用 <code>__declspec(import)</code> ；</li></ul> <p>因此，综合上述要点，针对DLL，一个最全最标准的函数声明 <code>.h</code> 就可以是如下格式：</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br></div><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifdef</span> XXXX</span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYEXPORT __declspec(dllexport)</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> MYEXPORT __declspec(dllimport)</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

MYEXPORT <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MYEXPORT <span class="token keyword">long</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> __cplusplus</span>
<span class="token punctuation">}</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="附记"><a href="#附记" class="header-anchor">#</a> 附记</h2> <h3 id="查看导出函数"><a href="#查看导出函数" class="header-anchor">#</a> 查看导出函数</h3> <blockquote><p>使用VS的命令行工具，并使用 <code>dumpbin</code> 命令。</p></blockquote> <p>查看DLL中的导出函数：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>dumpbin /exports xxx.dll
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查看LIB中的导出函数：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>dumpbin /linkermember xxx.lib
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过上述方式可以做到：</p> <ul><li>剖析一个DLL项目所生成的 <code>.lib</code> 和 <code>.dll</code></li> <li>并通过对比 <code>.h</code> ，来查看各自的函数名称的不同</li></ul> <h3 id="从-dll-提取-lib"><a href="#从-dll-提取-lib" class="header-anchor">#</a> 从 DLL 提取 LIB</h3> <blockquote><p>有时候我们只有 <code>.dll</code> ，只能动态加载，但此时若想静态加载，则需要 <code>.lib</code> 文件；可使用VS的命令行工具，按照如下步骤进行：</p></blockquote> <ol><li>首先，需要先根据 <code>.dll</code> 来得到 <code>.def</code> ：</li></ol> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>dumpbin /exports xxx.dll <span class="token operator">&gt;</span> xxx.def
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>其次，根据 <code>.def</code> 文件来得到 <code>.lib</code> ，但注意：
<ul><li>要确保 <code>.def</code> 已经被修改为标准的 <code>.def</code> 文件格式</li> <li>其中，<code>x86</code> 或者 <code>x64</code> 表示所生成的 <code>.lib</code> 对应的目标机器类型</li></ul></li></ol> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>lib /def:xxx.def /machine:x86 out/:xxx.lib
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意的是：</p> <ol><li>这样的提取方式采用的是 C/C++默认的 <code>__cdecl</code> <em><strong>调用约定</strong></em> 和 <em><strong>C编译器函数名修饰</strong></em> ；</li> <li>因此，要注意是否与DLL提供者的 <em><strong>调用约定</strong></em> 一致；</li> <li>另外，头文件 <code>.h</code> 总是需要的，可自己编写，但要确保 <em><strong>调用约定</strong></em> 和 <em><strong>编译器函数名修饰</strong></em> 与DLL提供者一致；</li></ol> <h3 id="dll-forward-技术"><a href="#dll-forward-技术" class="header-anchor">#</a> DLL FORWARD 技术</h3> <p><em>考虑一种需求场景：</em></p> <blockquote><ul><li>厂商 A 提供了 <code>A.dll</code></li> <li>服务商 S 需要进行一些包装，并且增加一些函数后作为 <code>S.dll</code> 再提供给用户</li> <li>而且，服务商 S 希望对于用户来说，只需要统一的访问 <code>S.dll</code> 即可，而不用同时面对 <code>A.dll</code> 和 <code>S.dll</code></li> <li>但是，服务商没有厂商 <code>A.dll</code> 的源代码，就算有，可能也存在编译、依赖等不可知的问题</li></ul></blockquote> <p>那么，<em><strong>dll forword</strong></em> 技术就是用来解决这个问题的：</p> <ul><li>假设 <code>A.dll</code> 中有函数 <code>fa1</code> 和 <code>fa2</code> ，那么，在 <code>S.dll</code> 中只需如下进行 <em><strong>forward</strong></em> ：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">pragma</span> comment(linker, &quot;/export:fa1=A.fa1&quot;)</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> comment(linker, &quot;/export:fa2=A.fa2&quot;)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>这样，<code>S.dll</code> 中就包含了 <code>A.dll</code> 中的方法，剩余的工作就是在 <code>S.dll</code> 中开发新增接口即可：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">fs3</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>因此，对于用户来说，统一通过 <code>S.dll</code>，即可以访问到 <code>fa1</code>，<code>fa2</code>，<code>fs3</code> 。</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">4/8/2020, 6:14:08 AM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.b639eb72.js" defer></script><script src="/assets/js/2.5df156af.js" defer></script><script src="/assets/js/5.339eb2f5.js" defer></script>
  </body>
</html>
