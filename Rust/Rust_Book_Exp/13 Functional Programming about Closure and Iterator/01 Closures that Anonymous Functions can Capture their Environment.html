<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>13.1. 匿名函数 Closure | Lindorof</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="Lindorof's Blog">
    <link rel="preload" href="/assets/css/0.styles.8ac2847d.css" as="style"><link rel="preload" href="/assets/js/app.b639eb72.js" as="script"><link rel="preload" href="/assets/js/2.5df156af.js" as="script"><link rel="preload" href="/assets/js/68.80f05874.js" as="script"><link rel="prefetch" href="/assets/js/10.ee4568ff.js"><link rel="prefetch" href="/assets/js/11.8db0767a.js"><link rel="prefetch" href="/assets/js/12.92a4e660.js"><link rel="prefetch" href="/assets/js/13.e2450b62.js"><link rel="prefetch" href="/assets/js/14.5ae14743.js"><link rel="prefetch" href="/assets/js/15.62a967cf.js"><link rel="prefetch" href="/assets/js/16.3482df63.js"><link rel="prefetch" href="/assets/js/17.881a9d91.js"><link rel="prefetch" href="/assets/js/18.d6e19ee5.js"><link rel="prefetch" href="/assets/js/19.caf0829a.js"><link rel="prefetch" href="/assets/js/20.a80e123c.js"><link rel="prefetch" href="/assets/js/21.9c810086.js"><link rel="prefetch" href="/assets/js/22.bc5f69cb.js"><link rel="prefetch" href="/assets/js/23.f15ef55d.js"><link rel="prefetch" href="/assets/js/24.b8714e3e.js"><link rel="prefetch" href="/assets/js/25.d673c092.js"><link rel="prefetch" href="/assets/js/26.28d57b84.js"><link rel="prefetch" href="/assets/js/27.d8b15b76.js"><link rel="prefetch" href="/assets/js/28.2574be13.js"><link rel="prefetch" href="/assets/js/29.54667d47.js"><link rel="prefetch" href="/assets/js/3.f6602695.js"><link rel="prefetch" href="/assets/js/30.dd697263.js"><link rel="prefetch" href="/assets/js/31.aafbc8db.js"><link rel="prefetch" href="/assets/js/32.5fe2531d.js"><link rel="prefetch" href="/assets/js/33.c3dfca3c.js"><link rel="prefetch" href="/assets/js/34.22613e38.js"><link rel="prefetch" href="/assets/js/35.aad9af2b.js"><link rel="prefetch" href="/assets/js/36.badbd522.js"><link rel="prefetch" href="/assets/js/37.45905373.js"><link rel="prefetch" href="/assets/js/38.ab0de43e.js"><link rel="prefetch" href="/assets/js/39.d1a7492c.js"><link rel="prefetch" href="/assets/js/4.c7710dca.js"><link rel="prefetch" href="/assets/js/40.92c4cb14.js"><link rel="prefetch" href="/assets/js/41.cc19be50.js"><link rel="prefetch" href="/assets/js/42.c9b4b585.js"><link rel="prefetch" href="/assets/js/43.1af966c8.js"><link rel="prefetch" href="/assets/js/44.40ebac1c.js"><link rel="prefetch" href="/assets/js/45.469b8553.js"><link rel="prefetch" href="/assets/js/46.eb491d21.js"><link rel="prefetch" href="/assets/js/47.03d1fbf2.js"><link rel="prefetch" href="/assets/js/48.af296c16.js"><link rel="prefetch" href="/assets/js/49.3a42b55b.js"><link rel="prefetch" href="/assets/js/5.339eb2f5.js"><link rel="prefetch" href="/assets/js/50.ef35a161.js"><link rel="prefetch" href="/assets/js/51.284d50de.js"><link rel="prefetch" href="/assets/js/52.c4983004.js"><link rel="prefetch" href="/assets/js/53.83c193e1.js"><link rel="prefetch" href="/assets/js/54.08f26cd6.js"><link rel="prefetch" href="/assets/js/55.ef20313b.js"><link rel="prefetch" href="/assets/js/56.dc2772cf.js"><link rel="prefetch" href="/assets/js/57.add26447.js"><link rel="prefetch" href="/assets/js/58.ff8f2704.js"><link rel="prefetch" href="/assets/js/59.43fdbc04.js"><link rel="prefetch" href="/assets/js/6.0ce72a94.js"><link rel="prefetch" href="/assets/js/60.1a27c7c3.js"><link rel="prefetch" href="/assets/js/61.9ca63ff6.js"><link rel="prefetch" href="/assets/js/62.9ab09b12.js"><link rel="prefetch" href="/assets/js/63.a6b6d595.js"><link rel="prefetch" href="/assets/js/64.5e9ac56b.js"><link rel="prefetch" href="/assets/js/65.bcfb6015.js"><link rel="prefetch" href="/assets/js/66.5024eb22.js"><link rel="prefetch" href="/assets/js/67.5d83f99f.js"><link rel="prefetch" href="/assets/js/69.6f9ff293.js"><link rel="prefetch" href="/assets/js/7.726c7fbf.js"><link rel="prefetch" href="/assets/js/70.92b749fb.js"><link rel="prefetch" href="/assets/js/71.a4248217.js"><link rel="prefetch" href="/assets/js/72.29aeb940.js"><link rel="prefetch" href="/assets/js/73.8918e90b.js"><link rel="prefetch" href="/assets/js/74.81fd32da.js"><link rel="prefetch" href="/assets/js/75.5357ccc2.js"><link rel="prefetch" href="/assets/js/76.66fc1725.js"><link rel="prefetch" href="/assets/js/77.6f29512b.js"><link rel="prefetch" href="/assets/js/78.a63871cd.js"><link rel="prefetch" href="/assets/js/79.c646997c.js"><link rel="prefetch" href="/assets/js/8.81d630fc.js"><link rel="prefetch" href="/assets/js/80.b5d5ad39.js"><link rel="prefetch" href="/assets/js/81.601aa569.js"><link rel="prefetch" href="/assets/js/82.99bc0640.js"><link rel="prefetch" href="/assets/js/83.06d4defc.js"><link rel="prefetch" href="/assets/js/84.44856307.js"><link rel="prefetch" href="/assets/js/85.3b88ee80.js"><link rel="prefetch" href="/assets/js/86.47c806cb.js"><link rel="prefetch" href="/assets/js/87.b5201cdf.js"><link rel="prefetch" href="/assets/js/88.f9ce8655.js"><link rel="prefetch" href="/assets/js/89.c1f12bf1.js"><link rel="prefetch" href="/assets/js/9.b6118830.js"><link rel="prefetch" href="/assets/js/90.e0f850a2.js"><link rel="prefetch" href="/assets/js/91.8166ca11.js"><link rel="prefetch" href="/assets/js/92.6ba6ce27.js"><link rel="prefetch" href="/assets/js/93.6e09fb58.js"><link rel="prefetch" href="/assets/js/94.1b324565.js"><link rel="prefetch" href="/assets/js/95.5308659f.js"><link rel="prefetch" href="/assets/js/96.306bee11.js"><link rel="prefetch" href="/assets/js/97.6e231fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ac2847d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Lindorof" class="logo"> <span class="site-name can-hide">Lindorof</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Rust/Rust_Book_Exp/" aria-current="page" class="sidebar-link">「RustBook」学习心得</a></li><li><a href="/Rust/Rust_Book_Exp/01 Getting Started/01 Getting Started.html" class="sidebar-link">1. 开始</a></li><li><a href="/Rust/Rust_Book_Exp/02 Programming a Guessing Game/01 Programming a Guessing Game.html" class="sidebar-link">2. 猜谜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3. 基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>4. 所有权</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>5. 结构体</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>6. 枚举</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>7. 模块</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>8. 集合</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>9. 错误处理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>10. 泛型及生命周期</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>11. 自动测试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>12. 命令行</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>13. 闭包及迭代器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Rust/Rust_Book_Exp/13 Functional Programming about Closure and Iterator/01 Closures that Anonymous Functions can Capture their Environment.html" class="active sidebar-link">13.1. 匿名函数 Closure</a></li><li><a href="/Rust/Rust_Book_Exp/13 Functional Programming about Closure and Iterator/02 Processing a Series of Items with Iterators.html" class="sidebar-link">13.2. 迭代器 Iterator</a></li><li><a href="/Rust/Rust_Book_Exp/13 Functional Programming about Closure and Iterator/03 Improving Our IO Project.html" class="sidebar-link">13.3. 改进 minigrep</a></li><li><a href="/Rust/Rust_Book_Exp/13 Functional Programming about Closure and Iterator/04 Comparing Performance about Loop and Iterator.html" class="sidebar-link">13.4. 性能比较 Loop &amp; Iterator</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>14. Cargo 和 Crates.io</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>15. 智能指针</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>16. 无畏并发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>17. 面向对象</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>18. 模式与匹配</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>19. 高级特征</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_13-1-匿名函数-closure"><a href="#_13-1-匿名函数-closure" class="header-anchor">#</a> 13.1. 匿名函数 Closure</h1> <h2 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h2> <h3 id="functional-programming"><a href="#functional-programming" class="header-anchor">#</a> <em>Functional Programming</em></h3> <ul><li>即函数式编程</li> <li>函数可以被当作一种值，从而可以赋值给变量，或作为函数的返回值</li> <li>包括 Cosure ，Iterator 等</li></ul> <h3 id="closure"><a href="#closure" class="header-anchor">#</a> <em>Closure</em></h3> <ul><li>即匿名函数</li> <li>可以将其存储在变量中，或者作为参数传递给另一个函数</li> <li>与函数不同的是，Closure 是闭包的，也就是说它记录了被创建时的上下文环境</li> <li>因此，可以在一个位置创建 Closure ，然后在另一个上下文环境中使用它</li></ul> <h2 id="问题的提出"><a href="#问题的提出" class="header-anchor">#</a> 问题的提出</h2> <h3 id="场景描述"><a href="#场景描述" class="header-anchor">#</a> 场景描述</h3> <blockquote><p>为了讲解 Closure ，原文 The Book 绞尽脑汁举了个例子，关于健身计划的，代码非常蹩脚，而且实际上原文中提到的问题是可以有其它解决办法的，只是不像 Closure 那么简洁。所以本书中我们不用在意实际的场景是不是健身计划，直接用代码来描述即可。</p></blockquote> <p>首先，有个运算函数比较耗时，这个耗时过程用 <code>sleep</code> 来模拟：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// 使用线程</span>
<span class="token keyword">use</span> std<span class="token punctuation">::</span>thread<span class="token punctuation">;</span>
<span class="token comment">// 时间操作</span>
<span class="token keyword">use</span> std<span class="token punctuation">::</span>time<span class="token punctuation">::</span>Duration<span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function">expensive</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span>
    <span class="token comment">// sleep 2秒之后返回</span>
    thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>然后，开始蹩脚的代码，简单来说，就是根据输入参数，会调用零次、一次、多次 <code>expensive</code> ：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">ugly</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> r<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> v <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token punctuation">{</span>	
        <span class="token comment">// 调用了两次</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.1 {}&quot;</span><span class="token punctuation">,</span> <span class="token function">expensive</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.2 {}&quot;</span><span class="token punctuation">,</span> <span class="token function">expensive</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> r <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 调用了一次</span>
            <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.1 {}&quot;</span><span class="token punctuation">,</span> <span class="token function">expensive</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 调用了零次</span>
			<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="问题改进"><a href="#问题改进" class="header-anchor">#</a> 问题改进</h3> <p>我们打算改进代码，希望只调用一次，所以先调用函数得到结果，再根据条件判断，直接访问结果值：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">ugly</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> r<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先调用函数得到结果</span>
	<span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token function">expensive</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token keyword">if</span> v <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token punctuation">{</span>
        <span class="token comment">// 两次访问结果</span>
		<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.1 {}&quot;</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.2 {}&quot;</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> r <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 一次访问结果</span>
			<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.1 {}&quot;</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 零次访问结果</span>
			<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="余留问题"><a href="#余留问题" class="header-anchor">#</a> 余留问题</h3> <p>上面的改进方式仍然存在如下问题：</p> <ol><li>虽然避免了多次调用函数，但函数仍然总是被调用了一次</li> <li>函数总是先执行函数并等待结果，即使某些情况下并不需要调用函数，例如 <code>B.0</code></li> <li>函数和函数执行结果是两份关联的信息，但此时这两份信息是分离的</li> <li>为了存储函数执行结果，增加了局部变量，且这个局部变量所存储的信息与函数本身是分离的</li></ol> <h3 id="解决目标"><a href="#解决目标" class="header-anchor">#</a> 解决目标</h3> <p>我们希望这个例子用下面的方式来解决，且 Closure 可以解决：</p> <ul><li>函数只被调用一次</li> <li>需要结果时才调用函数</li> <li>即使多个地方需要结果，也只调用一次函数</li> <li>如果某些地方不需要结果，则不会调用函数</li></ul> <h2 id="closure-语法"><a href="#closure-语法" class="header-anchor">#</a> Closure 语法</h2> <h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h3> <p>先看个例子，将上面的 <code>expensive</code> 函数改为 Closure 的语法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> ret_closure <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>vc<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>
    thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vc
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>需要注意的是：</p> <ul><li>此时 <code>ret_closure</code> 保存的并不是函数的执行结果，而是函数本身</li> <li>定义 Closure 的时候，只是定义了函数本身，函数并没有被执行</li></ul> <h3 id="语法规则"><a href="#语法规则" class="header-anchor">#</a> 语法规则</h3> <p>语法如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> var <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> <span class="token comment">/*code*/</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>语法说明：</p> <ul><li>函数用 <code>(p1, p2)</code> 来表示参数，但 Closure 用 <code>|p1, p2|</code></li> <li>Rust 认为采用 <code>|</code> 来囊括参数的原因是该语法与 Smalltalk 和 Ruby 很像，但我并不了解这两门语言</li> <li>Closure 的代码块用 <code>{}</code> ，与函数是一致的</li> <li>Closure 本身是一种数据，可以赋值给变量，因此末尾的 <code>;</code> 并不是 Closure 语法的一部分，而是 <code>let</code> 语句的结束</li> <li>如果 Closure 只有一句代码，则 <code>{}</code> 可以省略</li></ul> <h3 id="参数和返回值的类型"><a href="#参数和返回值的类型" class="header-anchor">#</a> 参数和返回值的类型</h3> <p>从语法中可以看到：</p> <ul><li>Closure 并不需要类似函数的 <code>-&gt; type</code> 来说明返回值的类型</li> <li>而且 <code>|p1, p2|</code> 里面的参数也不需要说明类型</li></ul> <p>这就是 Cosure 与 函数的一些不同：</p> <ul><li>函数需要明确的定义函数名称、参数和返回值类型，因为函数需要提供给外部使用</li> <li>但 Closure 不需要像函数这么严格，因为 Closure 是一种数据，可以存放于变量中</li> <li>因此 Closure 不需要函数名称，不需要提供给外部使用，而且，参数和返回值类型都可以省略，这样可以让 Closure看起来简洁一些</li> <li>另外，Closure 一般在代码内部被定义和使用，所以编译器能够自动推断出参数和返回值类型</li></ul> <h3 id="语法举例"><a href="#语法举例" class="header-anchor">#</a> 语法举例</h3> <p>下面是几种 Closure 的定义方式，可以看到有简单的写法，也有复杂的写法：</p> <blockquote><p>注意，为了对比几种写法的区别，因此故意使用了空格来进行对齐</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// 函数的定义方式</span>
<span class="token keyword">fn</span>  <span class="token function">add_one_v1</span>   <span class="token punctuation">(</span>x<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment">// Closure - 最全面的定义方式</span>
<span class="token keyword">let</span> add_one_v2 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>x<span class="token punctuation">:</span> u32<span class="token punctuation">|</span></span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Closure - 省略返回值类型</span>
<span class="token keyword">let</span> add_one_v3 <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>x<span class="token punctuation">|</span></span>             <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Closure - 省略代码块的 {}</span>
<span class="token keyword">let</span> add_one_v4 <span class="token operator">=</span> <span class="token operator">|</span>x<span class="token operator">|</span>               x <span class="token operator">+</span> <span class="token number">1</span>  <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="参数类型推断"><a href="#参数类型推断" class="header-anchor">#</a> 参数类型推断</h3> <p>假设有下面这个 Closure ：</p> <blockquote><p>注意，这样的 Closure 是没有任何意义的，因为它的作用就是用来演示，因此变量名故意叫做 <code>worthless</code></p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">let</span> worthless <span class="token operator">=</span> <span class="token operator">|</span>x<span class="token operator">|</span> x<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>那么，此时 <code>x</code> 的类型是未知的，编译器会根据第一次对该 Closure 的调用来决定参数类型：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// 此时参数x的类型被确定为i32</span>
<span class="token keyword">let</span> i1 <span class="token operator">=</span> <span class="token function">worthless</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后再进行一次调用，编译器报错：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// 编译器错误提示&quot;参数类型不匹配&quot;</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">worthless</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="closure-类型"><a href="#closure-类型" class="header-anchor">#</a> Closure 类型</h2> <h3 id="关于-closure-的类型"><a href="#关于-closure-的类型" class="header-anchor">#</a> 关于 Closure 的类型</h3> <p>每个 Closure 本身的类型是唯一的：</p> <ul><li>前面讲过，Closure 本质是一种数据，而既然是数据，就会有类型</li> <li>因此，每个 Closure 都有唯一的匿名的类型，这个唯一性是编译器自行完成的</li> <li>即使两个 Closure 的 Signature (参数个数、参数类型、返回值类型等) 完全一样，它们的类型也是不一样的</li></ul> <p>为何 Closure 的类型具有唯一性：</p> <ul><li>这是我自己的理解，我认为有几方面原因</li> <li>第一，Closure 也有 Signature ，不同的 Closure 的 Signature 可能不同，这与函数是一致的</li> <li>第二，Closure 是匿名的，没有函数名，所以 Rust 需要理解为每个 Closure 的函数名都是不同的</li> <li>第三，Closure 涉及到闭包，也就是对当前上下文环境的访问，这个后续会讲。因此，一方面，每个 Closure 的上下文环境可能是不一样的；一方面，每个 Closure 对上下文环境的访问也是不同的，可能只是读取上下文数据，也可能会修改上下文数据；总之，Closure 闭包的不同，导致了每个 Closure 的不同</li> <li>在前面的例子里，Closure 都是被直接赋值给变量，所以我们不需要关注也可以忽略 Closure 本身的类型</li> <li>但是，如果要将 Closure 作为函数的参数、函数的返回值、struct 的 field，就需要说明类型，因此，在这些场景下，如何标注 Closure 的类型就成为一个问题</li></ul> <h3 id="表达-closure-的类型"><a href="#表达-closure-的类型" class="header-anchor">#</a> 表达 Closure 的类型</h3> <p>根据前面对 Closure 类型唯一性的讲解，如果要表达 Closure 的类型，需要考虑三方面问题</p> <ol><li>Signature，即参数和返回值</li> <li>Closure 的匿名性，也就是没有函数名</li> <li>Closure 的闭包特性</li></ol> <p>因此，Rust 用下面的方式来解决这些问题：</p> <ol><li>Signature 比较简单，与函数一致，用 <code>()</code> 来表示参数，用 <code>-&gt; type</code> 来表示返回值</li> <li>Closure 的匿名性，这个不好表达，先放一下</li> <li>Closure 的闭包特性，Rust 归为三类，分别是 <code>Fn / FnMut / FnOnce</code> ，具体差异后续会讲</li></ol> <p>进一步，Rust 的思考方式是：</p> <ul><li>除了 Signature 可以明确表达，另外的匿名性和闭包特性都无法表达为确切的类型，而只能理解为一种特性</li> <li>也就是说，Closure 具备某些特性，包括匿名、闭包，而这些特性可以用 Trait 来表达</li> <li>所以，<code>Fn / FnMut / FnOnce</code> 是三种针对 Closure 的 Trait</li> <li>因此，如果要表达 Closure 的类型，需要使用 Generic 和 Trait</li></ul> <p>此处先暂时只使用 <code>Fn</code> ，我们可以顺其自然的表达出 Closure 的类型：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token function">Fn</span><span class="token punctuation">(</span>type1<span class="token punctuation">,</span> type2<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span><span class="token keyword">type</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>用 struct 举例如下：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> SthStruct<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
	<span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32
<span class="token punctuation">{</span>
	sth_closure<span class="token punctuation">:</span> T
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="问题的解决"><a href="#问题的解决" class="header-anchor">#</a> 问题的解决</h2> <p>先回顾一下前面期望的问题解决目标：</p> <ul><li>函数只被调用一次</li> <li>需要结果时才调用函数</li> <li>即使多个地方需要结果，也只调用一次函数</li> <li>如果某些地方不需要结果，则不会调用函数</li></ul> <h3 id="解决方式"><a href="#解决方式" class="header-anchor">#</a> 解决方式</h3> <blockquote><p>首先定义 struct ，存储 Closure 和计算结果。需要注意 val 的类型是 <code>Option</code> ，因为在没有计算之前，val 的值是 <code>None</code></p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
	<span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32
<span class="token punctuation">{</span>
	cal<span class="token punctuation">:</span> T<span class="token punctuation">,</span>
	val<span class="token punctuation">:</span> Option<span class="token operator">&lt;</span>u32<span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>然后为该 struct 实现一些方法，注意 <code>impl</code> 写法如下</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
	<span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token function">Fn</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>在  <code>impl</code> 中实现 <code>new</code> 方法，用来创建该 struct 的实例</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>cal<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">-&gt;</span> Cacher<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    Cacher <span class="token punctuation">{</span>
        cal<span class="token punctuation">,</span>
        val<span class="token punctuation">:</span> None<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>然后实现取值方法，思路是：如果 <code>val</code> 不是 <code>None</code> ，则直接返回；否则调用 <code>cal</code> 来计算结果</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> arg<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> u32 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token keyword">let</span> None <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>val <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token function">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>cal<span class="token punctuation">)</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>val<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意：</p> <ul><li>调用 Closure 的方式是 <code>closure(arg)</code></li> <li>但是上面的代码里 Closure 是 <code>Self.cal</code> ，按照 C/C++ 的运算符结合特性，是可以写为 <code>self.cal(arg)</code> 的，因为 <code>.</code> 和 <code>()</code> 涉及的操作是从左到右结合，但 Rust 里必须写为 <code>(self.cal)(arg)</code> ，==也许是 Rust 里的运算符结合特性不同吧，暂时没有深究==</li></ul> <blockquote><p>最后，可以对前面的 <code>ugly</code> 函数改进如下</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">ugly</span><span class="token punctuation">(</span>v<span class="token punctuation">:</span> u32<span class="token punctuation">,</span> r<span class="token punctuation">:</span> u32<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建Cacher实例，参数是一个Closure</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> cacher <span class="token operator">=</span> Cacher<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token punctuation">|</span>vc<span class="token punctuation">|</span></span> <span class="token punctuation">{</span>
		thread<span class="token punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>Duration<span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vc
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> v <span class="token operator">&gt;=</span> <span class="token number">100</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用了一次Closure</span>
		<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.1 {}&quot;</span><span class="token punctuation">,</span> cacher<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 不再调用，直接获取结果</span>
		<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;A.2 {}&quot;</span><span class="token punctuation">,</span> cacher<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> r <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment">// 不再调用，直接获取结果</span>
			<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.1 {}&quot;</span><span class="token punctuation">,</span> cacher<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;B.0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="剩余问题"><a href="#剩余问题" class="header-anchor">#</a> 剩余问题</h3> <p>上面的 <code>Cacher</code> 存在一些小问题：</p> <ul><li>一旦 <code>Cacher</code> 实例执行过一次计算以后，就不会再执行第二次计算</li> <li>即使每次传入的 <code>arg</code> 值不同</li></ul> <p>例如下面的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">limitation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> c <span class="token operator">=</span> Cacher<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">|</span>a<span class="token operator">|</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用了一次Closure</span>
    <span class="token comment">// val已经被存储，值是1</span>
	<span class="token keyword">let</span> v1 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时不再调用Closure</span>
    <span class="token comment">// 直接返回实例c中的val</span>
	<span class="token keyword">let</span> v2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// v2得到的结果仍然是1</span>
	<span class="token function">assert_eq!</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>解决办法：</p> <ul><li>可以为不同的 <code>arg</code> 创建不同的 <code>Cacher</code> 实例</li> <li>另外的办法是，<code>Cacher</code> 内的 <code>val</code> 使用 <code>HashMap</code> ，其中，key 是 <code>arg</code> ，value 是 <code>closure(arg)</code> 的结果</li></ul> <h2 id="closure-闭包"><a href="#closure-闭包" class="header-anchor">#</a> Closure 闭包</h2> <h3 id="闭包特性"><a href="#闭包特性" class="header-anchor">#</a> 闭包特性</h3> <p>Closure 有一个函数不具备的功能，即闭包特性，也就是说，Closure 可以访问当前 Scope 的变量。看下面的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 在Closure中访问了变量x</span>
    <span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token comment">// 相当于参数8与变量x比较</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>但是函数不允许这种闭包特性：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 编译器错误提示，函数不允许闭包</span>
    <span class="token keyword">fn</span> <span class="token function">fequalx</span><span class="token punctuation">(</span>z<span class="token punctuation">:</span> i32<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> bool <span class="token punctuation">{</span> z <span class="token operator">==</span> x <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>关于闭包的内存：</p> <ul><li>闭包可以访问当前上下文的数据，而为了访问这些数据，可能产生内存的消耗</li> <li>例如数据的拷贝，数据的引用，所有权的转移等</li> <li>这些内存的消耗是 Rust 自动完成的，但程序员仍然需要知道这个事实</li> <li>函数不允许闭包，因此不会产生这些间接的内存消耗</li></ul> <p>根据闭包对上下文数据的访问方式，一共有三种 Trait ，且编译器能够自动推断出属于哪一种 Trait ：</p> <ul><li><code>Fn</code> ，只读取数据，本质是对数据的 <code>&amp;</code></li> <li><code>FnMut</code> ，修改数据内容，本质是对数据的 <code>&amp;mut</code></li> <li><code>FnOnce</code> ，对数据 Move 操作，The Book 说每个 Closure 都实现了 <code>FnOnce</code> 这个 Trait ，因为每个 Closure 都可以被调用至少一次，即 Once ，==但恕我理解不了，也不知道至少被调用 Once 的意义是什么，在我看来，<code>Fn</code> 的频率更高==</li></ul> <h3 id="fn"><a href="#fn" class="header-anchor">#</a> <code>Fn</code></h3> <p>要注意的是：</p> <ol><li>只对上下文数据进行读取操作</li> <li>因此如果编译器看到 Closure 对上下文数据只有读取行为，就推断为 <code>Fn</code></li> <li>因此容易忽略的点是，在 Closure 访问上下文数据时，本质是一种 Borrow ，即使是 <code>i32</code> 数据</li></ol> <blockquote><p>先看最简单的例子</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时Closure中其实是&amp;x</span>
    <span class="token comment">// 只是编译器自动解引用了</span>
    <span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>为了证明上面的 Closure 其实是 &amp;x ，可以做出如下修改</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时产生了&amp;x</span>
    <span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token comment">// 此时不允许x自身修改</span>
    x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>错误剖析：</p> <ul><li>编译器错误提示：在 Borrow 期间，不允许被引用的数据内容修改</li> <li>具体可以参考对所有权的讲解章节</li> <li>因此这个例子很清楚的看到，Closure 中使用的是 <code>&amp;x</code></li></ul> <blockquote><p>再看一个例子，不使用 i32 这种简单类型，使用 Vector</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时使用的是 &amp;x</span>
    <span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// x仍然能够被访问</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="fnmut"><a href="#fnmut" class="header-anchor">#</a> <code>FnMut</code></h3> <p>先说规则：</p> <ul><li>如果对上下文数据产生了修改，则是 <code>FnMut</code></li> <li>如果 Closure 是 <code>FnMut</code> ，则存储 Closure 的变量也必须是 <code>mut</code> 修饰</li> <li>如果 Closure 是 <code>FnMut</code> ，则只能使用 <code>mut</code> 变量来存储，但是 <code>mut</code> 变量可以存储 <code>Fn</code> 这种 Closure ，虽然这没有什么意义</li> <li>用 <code>mut</code> 变量来存储 <code>FnMut</code> ，只是表达了 <code>FnMut</code> 这个特性，而不是变量本身的值可以被修改</li> <li>只要有任何对上下文数据的修改行为，则必须是 <code>FnMut</code> ，即使对其它的数据只进行读取</li></ul> <blockquote><p>先看一个简单例子，说明 <code>FnMut</code> 本质是 <code>&amp;mut</code></p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token comment">// 此时产生了 &amp;mut x</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> equalx <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> z <span class="token operator">==</span> x <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 此时不允许x自身修改</span>
    x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>如果不对变量增加 <code>mut</code> 修饰，则编译器报错</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token comment">// 移除了 mut 修饰</span>
    <span class="token comment">// 编译器错误提示：mut Closure 才能使用 &amp;mut x</span>
    <span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> z <span class="token operator">==</span> x <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>可以使用 <code>mut</code> 变量来存储 <code>Fn</code> ，虽然这没有任何意义，编译器也会给出 warnning</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时使用 mut 修饰是没有意义的</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>存储 <code>FnMut</code> 的变量虽然是 <code>mut</code> 修饰，但不代表该变量本身可以被改变</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时equalx变量的类型已经确定</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>
    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 编译器错误提示：Closure类型不同</span>
    equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>错误剖析：</p> <ul><li>在对 <code>equalx</code> 重新赋值时，编译器的错误提示原文是 <code>expected closure, found a different closure</code></li> <li>由此可见，我们也可以理解为，<code>equalx</code> 是 <code>mut</code> 变量，可以被重新赋值，但是此时赋值给 <code>equalx</code> 的数据类型不匹配，虽然两个 Closure 看着是一模一样的</li> <li>这也再次印证了前面讲到的 Closure 类型，每个 Closure 都有唯一的匿名类型</li> <li>因此，即使变量是 <code>mut</code> 修饰，即使变量可以被重新赋值，但我们已经无法找到第二个符合其 Closure 类型的数据了</li> <li>所以，我们也可以直接理解为，存储 <code>FnMut</code> 的变量本身的值无法被改变，即使它是 <code>mut</code> 修饰</li></ul> <blockquote><p>只要对任何上下文数据进行过修改，则必须是 <code>FnMut</code> ，即使对其它数据只是读取操作</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">// 对x进行了修改，对y只是读取</span>
    <span class="token comment">// 但仍然必须使用mut来修饰equaly</span>
    <span class="token comment">// 否则编译器报错</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> equaly <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> z <span class="token operator">==</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equaly</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="fnonce"><a href="#fnonce" class="header-anchor">#</a> <code>FnOnce</code></h3> <p>先说规则：</p> <ul><li>与 <code>Fn</code> 一样，使用变量存储 <code>FnOnce</code> 时，不需要对变量增加 <code>mut</code> 修饰，只有 <code>FnMut</code> 才需要对变量进行 <code>mut</code> 修饰</li> <li>当然，即使要为变量增加 <code>mut</code> 修饰，编译器也只是给出 wanning ，因为这样做没有任何意义</li> <li>编译器在推断闭包行为时，可能会有歧义，可以推断为 <code>Fn</code> ，也可以推断为 <code>FnOnce</code> ，此时编译器就会使用 <code>Fn</code> ，而不是 <code>FnOnce</code></li> <li>因此，可以使用 <code>move</code> 来修饰 Closure ，强制要求编译器将 Closure 推断为 <code>FnOnce</code></li> <li>但要注意的是，Move 行为对于简单类型来说，其实是 Copy ，对于对象来说，才是 Move ，才涉及到所有权的转变，参考讲解所有权的章节</li> <li>因此，有时候对于简单类型例如 i32 来说，强制使用 <code>move</code> 可以简化一些程序逻辑</li></ul> <blockquote><p>先看一个 <code>FnOnce</code> 的例子</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// x被赋值给m，因此x的所有权被move给m</span>
    <span class="token comment">// 在此Closure之后，x已不再可用</span>
    <span class="token comment">// 因此sth_move的Trait是FnOnce</span>
    <span class="token keyword">let</span> sth_move <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> <span class="token keyword">let</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span> m <span class="token operator">==</span> z <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">sth_move</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 此时访问x，编译器错误提示：</span>
    <span class="token comment">// &quot;x已被move，不可访问&quot;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>下面的例子，编译器推断为 <code>Fn</code> ，而不是 <code>FnOnce</code> ，注意看注释</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时编译器推断为Fn</span>
    <span class="token comment">// 而不是FnOnce</span>
	<span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

    <span class="token comment">// 因此编译器错误提示：</span>
    <span class="token comment">// 被Borrow的数据不允许改变</span>
	x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

	<span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>下面的例子使用的 Vector 类型，可以看到并没有被 Move</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时使用的是 &amp;x</span>
	<span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

	<span class="token function">equalx</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时x仍然可以被访问</span>
	<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>对于简单类型，强制要求编译器推断为 <code>FnOnce</code> ，而不是 <code>Fn</code> ，使用关键字 <code>move</code></p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时x被Move</span>
	<span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>
    <span class="token comment">// 因此x是简单类型</span>
    <span class="token comment">// 所以本质是拷贝了x</span>
    <span class="token comment">// 因此x仍然可用</span>
	x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">// 只有4才相等</span>
	<span class="token function">assert!</span><span class="token punctuation">(</span><span class="token function">equalx</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>代码剖析：</p> <ul><li>上述代码强制使用了 <code>move</code></li> <li>但是对于简单类型，例如例子中的 <code>x</code> 是 <code>i32</code> ，因此 <code>move</code> 的本质是拷贝了 <code>x</code></li> <li>所以，相当于 Closure 自己开辟了空间来存储 <code>i32</code> 数据</li> <li>因此，此时 Closure 所存储的 <code>x</code> 的值被固定了，也就是 4</li> <li>所以，之后 <code>x</code> 仍然可用，也没被 Borrow ，可以修改 <code>x</code> 的值</li> <li>但是，不管后续对 <code>x</code> 的值如何修改，Closure 中存储的值都是 4</li></ul> <blockquote><p>现在再看 Vector ，强制要求编译器推断为 <code>FnOnce</code> ，而不是 <code>Fn</code> ，使用关键字 <code>move</code></p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时x被强制move</span>
	<span class="token keyword">let</span> equalx <span class="token operator">=</span> <span class="token keyword">move</span> <span class="token operator">|</span>z<span class="token operator">|</span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>

	<span class="token function">equalx</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 编译器报错</span>
    <span class="token comment">// 此时x已不可访问</span>
	<span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="closure-参数"><a href="#closure-参数" class="header-anchor">#</a> Closure 参数</h2> <p>何时需要显式标注 Closure 的参数：</p> <ul><li>虽然前面讲过，我们不需要显式的标注 Closure 的参数类型</li> <li>但是在某些情况下，对 Closure 参数的标注是必须的，因为 Closure 也同样涉及到对实参所有权的影响</li> <li>下面需要几个例子来展示一些需要标注 Closure 参数的情况，但这些例子是不全的，只是抛砖引玉</li> <li>从下面的例子能够看到，编译器对 Closure 的实参，默认是按照 Move 的方式来传递的，如果我们的实参传递方式变化，例如 <code>&amp;</code> 方式，则都需要我们显式的标注 Closure 的形参</li></ul> <blockquote><p>下面的例子，看到作为参数传入的 Vector 被 Move 了</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 首先是x被move</span>
    <span class="token keyword">let</span> sth_move <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> <span class="token keyword">let</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span> m <span class="token operator">==</span> z <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 然后y的参数传递方式导致也被move</span>
    <span class="token function">sth_move</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 编译器报错，x不可访问</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 编译器报错，y不可访问</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>因此，尝试更改参数传递方式为 <code>&amp;</code>，并让编译器自动推断 Closure 的形参类型</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// x被move</span>
    <span class="token comment">// y被传递的是引用</span>
    <span class="token comment">// 因此此时需要对y手动解引用</span>
    <span class="token comment">// 即 *z</span>
    <span class="token keyword">let</span> sth_move <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> <span class="token keyword">let</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span> m <span class="token operator">==</span> <span class="token operator">*</span>z <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 实参用引用方式传入</span>
    <span class="token comment">// 并且期望编译器自动推断Closure的参数z类型</span>
    <span class="token comment">// 但实际上编译器无法推断</span>
    <span class="token function">sth_move</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>错误剖析：</p> <ul><li>我们不希望 <code>y</code> 被 Move</li> <li>因此传递实参时，使用了 <code>&amp;y</code> 的方式</li> <li>所以我们希望编译器自动推断 Closure 的形参 <code>z</code> 的类型为 <code>&amp;Vec&lt;i32&gt;</code></li> <li>但编译器自动推断失败了，==其实我很费解为何此时编译器不能推断出来==</li> <li>编译器的错误提示是：<code>consider giving this closure parameter a type, type must be known at this point</code> ，仿佛有一种编译器在求饶的既视感</li></ul> <blockquote><p>因此，对于上面的例子，我们需要标注 Closure 的形参类型</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">vec!</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 标注参数z的类型为&amp;Vec&lt;i32&gt;</span>
    <span class="token keyword">let</span> sth_move <span class="token operator">=</span> <span class="token closure-params"><span class="token punctuation">|</span>z<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Vec&lt;i32&gt;<span class="token punctuation">|</span></span> <span class="token punctuation">{</span> <span class="token keyword">let</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span> m <span class="token operator">==</span> <span class="token operator">*</span>z <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 实参用引用方式传入</span>
    <span class="token function">sth_move</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>同样的，对于简单类型，如果使用 <code>&amp;</code> 方式传递实参，编译器也要求我们显式标注 Closure 的参数类型</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">// 此时需要显式标注参数z的类型为&amp;i32</span>
    <span class="token comment">// 否则编译报错</span>
    <span class="token keyword">let</span> sth_move <span class="token operator">=</span> <span class="token operator">|</span>z<span class="token punctuation">:</span> <span class="token operator">&amp;</span>i32<span class="token operator">|</span> <span class="token operator">*</span>z <span class="token operator">==</span> x<span class="token punctuation">;</span>
    <span class="token comment">// 实参用引用方式传入</span>
    <span class="token function">sth_move</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/3/2019, 8:13:20 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Rust/Rust_Book_Exp/12 A Command Line Tool/07 Appendix.html" class="prev">
        12.7. 附：源码结构
      </a></span> <span class="next"><a href="/Rust/Rust_Book_Exp/13 Functional Programming about Closure and Iterator/02 Processing a Series of Items with Iterators.html">
        13.2. 迭代器 Iterator
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.b639eb72.js" defer></script><script src="/assets/js/2.5df156af.js" defer></script><script src="/assets/js/68.80f05874.js" defer></script>
  </body>
</html>
