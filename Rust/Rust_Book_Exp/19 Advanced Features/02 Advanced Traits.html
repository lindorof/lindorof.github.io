<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>19.2. 高级 trait | Lindorof</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="Lindorof's Blog">
    <link rel="preload" href="/assets/css/0.styles.8ac2847d.css" as="style"><link rel="preload" href="/assets/js/app.b639eb72.js" as="script"><link rel="preload" href="/assets/js/2.5df156af.js" as="script"><link rel="preload" href="/assets/js/91.8166ca11.js" as="script"><link rel="prefetch" href="/assets/js/10.ee4568ff.js"><link rel="prefetch" href="/assets/js/11.8db0767a.js"><link rel="prefetch" href="/assets/js/12.92a4e660.js"><link rel="prefetch" href="/assets/js/13.e2450b62.js"><link rel="prefetch" href="/assets/js/14.5ae14743.js"><link rel="prefetch" href="/assets/js/15.62a967cf.js"><link rel="prefetch" href="/assets/js/16.3482df63.js"><link rel="prefetch" href="/assets/js/17.881a9d91.js"><link rel="prefetch" href="/assets/js/18.d6e19ee5.js"><link rel="prefetch" href="/assets/js/19.caf0829a.js"><link rel="prefetch" href="/assets/js/20.a80e123c.js"><link rel="prefetch" href="/assets/js/21.9c810086.js"><link rel="prefetch" href="/assets/js/22.bc5f69cb.js"><link rel="prefetch" href="/assets/js/23.f15ef55d.js"><link rel="prefetch" href="/assets/js/24.b8714e3e.js"><link rel="prefetch" href="/assets/js/25.d673c092.js"><link rel="prefetch" href="/assets/js/26.28d57b84.js"><link rel="prefetch" href="/assets/js/27.d8b15b76.js"><link rel="prefetch" href="/assets/js/28.2574be13.js"><link rel="prefetch" href="/assets/js/29.54667d47.js"><link rel="prefetch" href="/assets/js/3.f6602695.js"><link rel="prefetch" href="/assets/js/30.dd697263.js"><link rel="prefetch" href="/assets/js/31.aafbc8db.js"><link rel="prefetch" href="/assets/js/32.5fe2531d.js"><link rel="prefetch" href="/assets/js/33.c3dfca3c.js"><link rel="prefetch" href="/assets/js/34.22613e38.js"><link rel="prefetch" href="/assets/js/35.aad9af2b.js"><link rel="prefetch" href="/assets/js/36.badbd522.js"><link rel="prefetch" href="/assets/js/37.45905373.js"><link rel="prefetch" href="/assets/js/38.ab0de43e.js"><link rel="prefetch" href="/assets/js/39.d1a7492c.js"><link rel="prefetch" href="/assets/js/4.c7710dca.js"><link rel="prefetch" href="/assets/js/40.92c4cb14.js"><link rel="prefetch" href="/assets/js/41.cc19be50.js"><link rel="prefetch" href="/assets/js/42.c9b4b585.js"><link rel="prefetch" href="/assets/js/43.1af966c8.js"><link rel="prefetch" href="/assets/js/44.40ebac1c.js"><link rel="prefetch" href="/assets/js/45.469b8553.js"><link rel="prefetch" href="/assets/js/46.eb491d21.js"><link rel="prefetch" href="/assets/js/47.03d1fbf2.js"><link rel="prefetch" href="/assets/js/48.af296c16.js"><link rel="prefetch" href="/assets/js/49.3a42b55b.js"><link rel="prefetch" href="/assets/js/5.339eb2f5.js"><link rel="prefetch" href="/assets/js/50.ef35a161.js"><link rel="prefetch" href="/assets/js/51.284d50de.js"><link rel="prefetch" href="/assets/js/52.c4983004.js"><link rel="prefetch" href="/assets/js/53.83c193e1.js"><link rel="prefetch" href="/assets/js/54.08f26cd6.js"><link rel="prefetch" href="/assets/js/55.ef20313b.js"><link rel="prefetch" href="/assets/js/56.dc2772cf.js"><link rel="prefetch" href="/assets/js/57.add26447.js"><link rel="prefetch" href="/assets/js/58.ff8f2704.js"><link rel="prefetch" href="/assets/js/59.43fdbc04.js"><link rel="prefetch" href="/assets/js/6.0ce72a94.js"><link rel="prefetch" href="/assets/js/60.1a27c7c3.js"><link rel="prefetch" href="/assets/js/61.9ca63ff6.js"><link rel="prefetch" href="/assets/js/62.9ab09b12.js"><link rel="prefetch" href="/assets/js/63.a6b6d595.js"><link rel="prefetch" href="/assets/js/64.5e9ac56b.js"><link rel="prefetch" href="/assets/js/65.bcfb6015.js"><link rel="prefetch" href="/assets/js/66.5024eb22.js"><link rel="prefetch" href="/assets/js/67.5d83f99f.js"><link rel="prefetch" href="/assets/js/68.80f05874.js"><link rel="prefetch" href="/assets/js/69.6f9ff293.js"><link rel="prefetch" href="/assets/js/7.726c7fbf.js"><link rel="prefetch" href="/assets/js/70.92b749fb.js"><link rel="prefetch" href="/assets/js/71.a4248217.js"><link rel="prefetch" href="/assets/js/72.29aeb940.js"><link rel="prefetch" href="/assets/js/73.8918e90b.js"><link rel="prefetch" href="/assets/js/74.81fd32da.js"><link rel="prefetch" href="/assets/js/75.5357ccc2.js"><link rel="prefetch" href="/assets/js/76.66fc1725.js"><link rel="prefetch" href="/assets/js/77.6f29512b.js"><link rel="prefetch" href="/assets/js/78.a63871cd.js"><link rel="prefetch" href="/assets/js/79.c646997c.js"><link rel="prefetch" href="/assets/js/8.81d630fc.js"><link rel="prefetch" href="/assets/js/80.b5d5ad39.js"><link rel="prefetch" href="/assets/js/81.601aa569.js"><link rel="prefetch" href="/assets/js/82.99bc0640.js"><link rel="prefetch" href="/assets/js/83.06d4defc.js"><link rel="prefetch" href="/assets/js/84.44856307.js"><link rel="prefetch" href="/assets/js/85.3b88ee80.js"><link rel="prefetch" href="/assets/js/86.47c806cb.js"><link rel="prefetch" href="/assets/js/87.b5201cdf.js"><link rel="prefetch" href="/assets/js/88.f9ce8655.js"><link rel="prefetch" href="/assets/js/89.c1f12bf1.js"><link rel="prefetch" href="/assets/js/9.b6118830.js"><link rel="prefetch" href="/assets/js/90.e0f850a2.js"><link rel="prefetch" href="/assets/js/92.6ba6ce27.js"><link rel="prefetch" href="/assets/js/93.6e09fb58.js"><link rel="prefetch" href="/assets/js/94.1b324565.js"><link rel="prefetch" href="/assets/js/95.5308659f.js"><link rel="prefetch" href="/assets/js/96.306bee11.js"><link rel="prefetch" href="/assets/js/97.6e231fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8ac2847d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Lindorof" class="logo"> <span class="site-name can-hide">Lindorof</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/archives.html" class="nav-link">
  文章清单
</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  建站指南
</a></div><div class="nav-item"><a href="https://github.com/lindorof" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Rust/Rust_Book_Exp/" aria-current="page" class="sidebar-link">「RustBook」学习心得</a></li><li><a href="/Rust/Rust_Book_Exp/01 Getting Started/01 Getting Started.html" class="sidebar-link">1. 开始</a></li><li><a href="/Rust/Rust_Book_Exp/02 Programming a Guessing Game/01 Programming a Guessing Game.html" class="sidebar-link">2. 猜谜游戏</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3. 基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>4. 所有权</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>5. 结构体</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>6. 枚举</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>7. 模块</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>8. 集合</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>9. 错误处理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>10. 泛型及生命周期</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>11. 自动测试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>12. 命令行</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>13. 闭包及迭代器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>14. Cargo 和 Crates.io</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>15. 智能指针</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>16. 无畏并发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>17. 面向对象</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>18. 模式与匹配</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>19. 高级特征</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Rust/Rust_Book_Exp/19 Advanced Features/01 Unsafe Rust.html" class="sidebar-link">19.1. 不安全代码</a></li><li><a href="/Rust/Rust_Book_Exp/19 Advanced Features/02 Advanced Traits.html" class="active sidebar-link">19.2. 高级 trait</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_19-2-高级-trait"><a href="#_19-2-高级-trait" class="header-anchor">#</a> 19.2. 高级 trait</h1> <p><em>在 Chapter10 讲解过 trait ，本节会进一步讲解 trait 更高级的特性。</em></p> <h2 id="关联类型"><a href="#关联类型" class="header-anchor">#</a> 关联类型</h2> <ul><li><em><strong>关联类型</strong></em>（<em><strong>associated type</strong></em>）是一种类型占位符，例如 <code>type Item</code></li> <li>用在 trait 中时，trait 无需关注具体类型是什么，而由 trait 的实现者来指定具体类型</li> <li>rust 标准库中，有一个 trait 是 <code>Iterator</code> ，它使用了关联类型</li></ul> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iterator <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Item<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Option<span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span>Item<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>剖析：</p> <ul><li>通过 <code>type Item</code> 定义了类型占位符，注意，名称不一定是 <code>Item</code> ，可以自定义</li> <li>其中 <code>next</code> 方法的返回值使用到了该占位符，即 <code>Option&lt;Self::Item&gt;</code></li> <li><code>Iterator</code> 这个 trait 不关注 <code>Item</code> 的具体类型是什么，由该 trait 的实现者来指定</li></ul> <p>现在我们不直接使用 <code>Iterator</code> ，而是自定义一个 trait ，并在 trait 中使用类型占位符：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">trait</span> TestIter <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Ret<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>剖析：</p> <ul><li>定义了一个 trait ，使用到的占位符是 <code>Ret</code></li> <li>在该 trait 中，<code>func1</code> 方法的返回值使用到了占位符，即 <code>Self::Ret</code> ，表示返回值是 <code>Ret</code> 这种类型</li> <li>而 <code>Ret</code> 的具体类型，由 trait 的实现者来决定</li></ul> <p>下面实现这个 trait ：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Counter<span class="token punctuation">;</span>

<span class="token keyword">impl</span> TestIter <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Ret <span class="token operator">=</span> i32<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret <span class="token punctuation">{</span>
        <span class="token number">8</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> Counter <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>剖析：</p> <ul><li>为 <code>Counter</code> 实现了 <code>TestIter</code> 这个 trait</li> <li>其中 <code>type Ret = i32</code> 的作用，就是指明 <code>Ret</code> 这个占位符的具体类型是 <code>i32</code></li> <li>实现该 trait 时，<code>func1</code> 的返回值可以写为 <code>Self::Ret</code> ，也可以写为 <code>i32</code> ，但写为 <code>Self::Ret</code> 更好一些，因为这样的话在修改 <code>Ret</code> 占位符的具体类型时，只需要更改一个地方</li></ul> <h2 id="泛型-trait"><a href="#泛型-trait" class="header-anchor">#</a> 泛型 trait</h2> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <p>上述的 <code>TestIter</code> 是可以用泛型 trait 来实现的：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>剖析：</p> <ul><li>用泛型 trait 时，不使用占位符，而是用泛型 <code>T</code> 来替代</li> <li>对应的，<code>next</code> 方法的返回值用到了 <code>T</code></li></ul> <p>然后实现泛型 trait：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Counter<span class="token punctuation">;</span>

<span class="token keyword">impl</span> Iter<span class="token operator">&lt;</span>i32<span class="token operator">&gt;</span> <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i32 <span class="token punctuation">{</span>
        <span class="token number">6</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Iter<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span>
        String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>剖析：</p> <ul><li>实现泛型 trait 时，需要指定 <code>T</code> 的具体类型</li> <li>从上面的例子看到，可以多次实现，每次实现时 <code>T</code> 的具体类型都不同</li></ul> <p>然后调用 trait 的方法：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> Counter <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> i<span class="token punctuation">:</span> i32 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s<span class="token punctuation">:</span> String <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{} - {}&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>剖析：</p> <ul><li>由于实现了多次泛型 trait ，因此对于 <code>c</code> 这个对象来说，同一个 trait 方法就被实现了多次</li> <li>所以，在调用 <code>c.next</code> 方法时，需要让 rust 能够推断出该方法对应的 <code>T</code> 类型，从而找到对应该类型的 trait 实现</li> <li>在上面的例子中，使用的推断方式是：<code>let i: i32</code> 或者 <code>let i: String</code> ，即通过指定变量的类型，来让 rust 找到 <code>impl Iter&lt;i32&gt; for Counter</code> 或者 <code>impl Iter&lt;String&gt; for Counter</code></li> <li><span style="background-color:#dddd00;">尚未理解的问题是：如果写为 <code>let i = c.next::&lt;i32&gt;();</code> ，则编译报错</span></li></ul> <h3 id="默认类型"><a href="#默认类型" class="header-anchor">#</a> 默认类型</h3> <ul><li>对于泛型 trait ，可以在定义 trait 时，为 <code>T</code> 指定默认类型</li> <li>例如 <code>trait Iter&lt;T=i32&gt;</code> ，语法是 <code>T=type</code> ，叫做 <em><strong>默认类型参数</strong></em>（<em><strong>default type parameter</strong></em>）</li> <li>在实现 trait 时，如果不指定 <code>T</code> 的具体类型，则使用 trait 定义时指定的默认类型</li> <li>该规则与 C++ 的默认参数类似</li></ul> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">trait</span> Iter<span class="token operator">&lt;</span>T<span class="token operator">=</span>i32<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> T<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> Counter<span class="token punctuation">;</span>

<span class="token keyword">impl</span> Iter <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i32 <span class="token punctuation">{</span>
        <span class="token number">6</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Iter<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span>
        String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>剖析：</p> <ul><li>定义 <code>Iter</code> 这个 trait 时，指定了默认类型参数，即 <code>T=i32</code></li> <li>上面的例子里，针对默认类型参数做了一次实现，即 <code>impl Iter for Counter</code></li> <li>同时，仍然可以为 <code>T</code> 指定其它类型，即 <code>impl Iter&lt;String&gt; for Counter</code></li></ul> <h3 id="运算符重载"><a href="#运算符重载" class="header-anchor">#</a> 运算符重载</h3> <p>使用运算符重载这个很好的例子，来讲解默认类型参数和占位符的结合使用：</p> <ul><li>与 C++ 不同，rust 不允许直接重载运算符</li> <li>rust 重载运算符的方式是，在 <code>std::ops</code> 中列出了运算符对应的 trait</li> <li>从而，为某个类型实现了对应的 trait 之后，这种类型就相当于重载了对应的运算符</li> <li>例如 <code>std::ops::Add</code> 这个 trait 对应的是 <code>+</code> 运算符</li></ul> <p>下面是 <code>std::ops::Add</code> 的定义：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">trait</span> Add<span class="token operator">&lt;</span>RHS<span class="token operator">=</span><span class="token keyword">Self</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> RHS<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>剖析：</p> <ul><li>这是一个泛型 trait ，并为 <code>RHS</code> 指定了默认类型，即 <code>Self</code></li> <li>同时，使用了占位符 <code>Output</code></li> <li>然后剖析 <code>add</code> 方法：
<ol><li>让 <code>self</code> 可以与另外一个类型相加</li> <li>另外一个类型可以通过 <code>RHS</code> 来指定，但默认是 <code>Self</code> 类型（因为大多数情况下都是同类型的两个变量相加）</li> <li>相加之后，返回的新类型通过占位符 <code>Output</code> 来指定</li> <li>该方法会 move 掉 <code>self</code> 的所有权，并返回新类型 <code>Output</code></li></ol></li></ul> <blockquote><p>举例：实现同类型相加</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span>Add<span class="token punctuation">;</span>

<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> Point <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> Add <span class="token keyword">for</span> Point <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> Point<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> Point<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Point <span class="token punctuation">{</span>
        Point <span class="token punctuation">{</span>
            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">+</span> other<span class="token punctuation">.</span>x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y <span class="token operator">+</span> other<span class="token punctuation">.</span>y<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> Point <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token operator">+</span> Point <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>剖析：</p> <ul><li>为 <code>Point</code> 类型实现 <code>+</code> 运算符重载</li> <li>由于是同类型相加，所以实现 <code>Add</code> 这个 trait 时，可以不标注 <code>RHS</code> 的具体类型，即使用默认类型参数</li> <li>但注意，对于 <code>add</code> 方法的 <code>other</code> 参数，仍然需要标注出类型，由于 <code>RHS</code> 的默认类型是 <code>Self</code> ，即同类型，所以此处标注为 <code>Point</code></li> <li>返回值通过占位符指定，该例子指定为 <code>Point</code> ，也是同类型</li></ul> <blockquote><p>举例：实现不同类型相加</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span>Add<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token function">Millimeters</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">Meters</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> Add<span class="token operator">&lt;</span>Meters<span class="token operator">&gt;</span> <span class="token keyword">for</span> Millimeters <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> Millimeters<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> Meters<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Millimeters <span class="token punctuation">{</span>
        <span class="token function">Millimeters</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token punctuation">(</span>other<span class="token number">.0</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>剖析：</p> <ul><li>为 <code>Millimeters</code> 重载 <code>+</code> 运算符，让 <code>Millimeters</code> 可以与 <code>Meters</code> 相加</li> <li>因此，在实现 <code>Add</code> 这个 trait 时，需要指定 <code>RHS</code> 的类型为 <code>Meters</code> ，即 <code>impl Add&lt;Meters&gt; for Millimeters</code></li> <li>然后指定占位符 <code>Output</code> 的类型为 <code>Millimeters</code> ，即相加以后返回的类型是 <code>Millimeters</code></li> <li>需要注意的是，我们是为 <code>Millimeters</code> 重载了运算符，<code>add</code> 方法中的 <code>self</code> 是 <code>Millimeters</code></li> <li>因此，顺序是 <code>Millimeters + Meters</code> ，而不是 <code>Meters + Millimeters</code></li> <li>例如，如果写为 <code>let m = Meters(1) + Millimeters(100)</code> ，则编译报错，提示 <code>Meters</code> 这个类型没有重载过 <code>+</code> 运算符</li></ul> <h2 id="关联-泛型总结"><a href="#关联-泛型总结" class="header-anchor">#</a> 关联&amp;泛型总结</h2> <p>前面已经了解了关联类型、泛型 trait ，现在需要拓展和总结一下这两个特征。</p> <h3 id="多个关联类型"><a href="#多个关联类型" class="header-anchor">#</a> 多个关联类型</h3> <p>下面是使用多个关联类型的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">trait</span> TestIter <span class="token punctuation">{</span>

    <span class="token comment">//func1使用到关联类型Ret1</span>
    <span class="token keyword">type</span> Ret1<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret1<span class="token punctuation">;</span>

    <span class="token comment">//func2使用到关联类型Para2和Ret2</span>
    <span class="token keyword">type</span> Para2<span class="token punctuation">;</span>
    <span class="token keyword">type</span> Ret2<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Para2<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> Counter<span class="token punctuation">;</span>
<span class="token keyword">impl</span> TestIter <span class="token keyword">for</span> Counter <span class="token punctuation">{</span>
    <span class="token comment">//实现func1</span>
    <span class="token keyword">type</span> Ret1 <span class="token operator">=</span> i32<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret1 <span class="token punctuation">{</span>
        <span class="token number">8</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//实现func2</span>
    <span class="token keyword">type</span> Para2 <span class="token operator">=</span> i32<span class="token punctuation">;</span>
    <span class="token keyword">type</span> Ret2 <span class="token operator">=</span> String<span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Para2<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span>Ret2 <span class="token punctuation">{</span>
        <span class="token function">format!</span><span class="token punctuation">(</span><span class="token string">&quot;return string: [{}]&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>剖析：</p> <ul><li>trait 中可以有多个关联类型</li> <li>但不管有多少个关联类型，对于某个类型(例如 <code>Counter</code>)来说，都只能实现一次该 trait</li></ul> <h3 id="关联-泛型的结合"><a href="#关联-泛型的结合" class="header-anchor">#</a> 关联&amp;泛型的结合</h3> <p>以 <code>std::ops::Add</code> 为例，使用到关联类型，也使用到泛型，看看下面的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span>Add<span class="token punctuation">;</span>

<span class="token comment">//微秒</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token function">MicroMeters</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//毫秒</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token function">Millimeters</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//秒</span>
<span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token function">Meters</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//为Millimeters实现trait，与Meters相加</span>
<span class="token keyword">impl</span> Add<span class="token operator">&lt;</span>Meters<span class="token operator">&gt;</span> <span class="token keyword">for</span> Millimeters <span class="token punctuation">{</span>
    <span class="token comment">//返回类型是Millimeters</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> Millimeters<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> Meters<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> Millimeters <span class="token punctuation">{</span>
        <span class="token function">Millimeters</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token punctuation">(</span>other<span class="token number">.0</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//为Millimeters实现trait，与MicroMeters相加</span>
<span class="token keyword">impl</span> Add<span class="token operator">&lt;</span>MicroMeters<span class="token operator">&gt;</span> <span class="token keyword">for</span> Millimeters <span class="token punctuation">{</span>
    <span class="token comment">//返回类型是MicroMeters</span>
    <span class="token keyword">type</span> Output <span class="token operator">=</span> MicroMeters<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> MicroMeters<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MicroMeters <span class="token punctuation">{</span>
        <span class="token function">MicroMeters</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">+</span> other<span class="token number">.0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//从打印结果看到：返回类型是Millimeters</span>
    <span class="token keyword">let</span> meter <span class="token operator">=</span> <span class="token function">Meters</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> milli <span class="token operator">=</span> <span class="token function">Millimeters</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> milli <span class="token operator">+</span> meter<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//从打印结果看到：返回类型是MicroMeters</span>
    <span class="token keyword">let</span> milli <span class="token operator">=</span> <span class="token function">Millimeters</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> micro <span class="token operator">=</span> <span class="token function">MicroMeters</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span> milli <span class="token operator">+</span> micro<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>剖析：</p> <ul><li>由于 <code>std::ops::Add</code> 有泛型类型 <code>RHS</code> ，所以可以为 <code>Millimeters</code> 实现多次 <code>Add</code> 这个 trait</li> <li>从例子中看到，对于 <code>Millimeters</code> 的每一次实现，都只能指定一次关联类型 <code>Output</code> 的具体类型</li> <li>但是，<em><strong>由于实现了多次 trait ，所以在每次实现中，可以为 <code>Output</code> 指定不同的类型</strong></em></li> <li>这仿佛是泛型 trait 为关联类型带来的彩蛋</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>下面对泛型 trait 和关联类型进行总结：</p> <ol><li><p>类型的个数：</p> <ul><li>对于关联类型，可以有多个占位符</li> <li>对于泛型 trait ，也可以有多个泛型参数</li></ul></li> <li><p>对 trait 类型的指定：</p> <ul><li>对于关联类型，在实现 trait 的 <code>impl</code> 内部指定占位符的具体类型</li> <li>对于泛型 trait ，在实现 trait 的 <code>impl</code> 语法内指定 <code>T</code> 的具体类型</li></ul></li> <li><p>对 trait 的实现次数：</p> <ul><li>对于关联类型，只能实现一次，因为只能指定一次占位符的具体类型</li> <li>对于泛型 trait ，可以实现多次 trait ，每次实现时为 <code>T</code> 指定不同的具体类型</li></ul></li> <li><p>调用 trait 方法时：</p> <ul><li>对于关联类型，直接调用 trait 方法即可，因为该 trait 只有一次实现</li> <li>对于泛型 trait ，需要提供类型信息以让 rust 能够找到正确的 trait 方法，因为该 trait 有多次实现</li></ul></li> <li><p>泛型与关联类型结合时：</p> <ul><li>对于泛型 trait ，可以实现多次 trait ，每次实现时为 <code>T</code> 指定不同的具体类型</li> <li>基于泛型 trait 的多次实现，可对应在每次实现中，为占位符指定不同的具体类型</li></ul></li></ol> <h2 id="完全限定语法"><a href="#完全限定语法" class="header-anchor">#</a> 完全限定语法</h2> <h3 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h3> <p>先看下面的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">/*
两个trait都是一样的方法
*/</span>
<span class="token keyword">trait</span> Grandpa <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">trait</span> Father <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> Child<span class="token punctuation">;</span>

<span class="token comment">//实现了两个trait</span>
<span class="token keyword">impl</span> Grandpa <span class="token keyword">for</span> Child <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Grandpa_with_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Grandpa_without_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">impl</span> Father <span class="token keyword">for</span> Child <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Father_with_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Father_without_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//自身也有跟trait一样的方法</span>
<span class="token keyword">impl</span> Child <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Child_with_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">fn</span> <span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Child_without_self&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>剖析：</p> <ul><li>两个 trait ，为了便于理解和记忆，一个是「爷爷」grandpa ，一个是「父亲」father</li> <li>这两个 trait 都是有两个方法，一个有 <code>&amp;self</code> ，一个没有， 为了便于理解和记忆，名称叫做 <code>with_self</code> 和 <code>without_self</code></li> <li>而 <code>Child</code> 类型实现了这两个 trait ，而且，该类型自身也有同名的两个方法</li> <li>这有点像 C++ 和 Java 常常讨论的多继承概念，但 rust 跟 Java 一样，不允许多继承（rust 也没有继承的概念），但允许实现多个 interface（在 rust 中 trait 可理解为 interface）</li></ul> <blockquote><p>❓所以问题是：</p> <ol><li>如何调用到 <code>Child</code> 自身的方法，如何调用到为不同 trait 实现的方法</li> <li>对于有 <code>&amp;self</code> 和没有 <code>&amp;self</code> 的方法，调用方式上有什么不同</li></ol></blockquote> <h3 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h3> <p>是时候给出安全限定语法了：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token operator">&lt;</span>Type <span class="token keyword">as</span> Trait<span class="token operator">&gt;</span><span class="token punctuation">::</span><span class="token function">function</span><span class="token punctuation">(</span>receiver<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>语法剖析：</p> <ol><li>rust 中的所有方法调用，本质上这个完全限定语法，但语法太过冗长，所以实际调用中会有各种简化的方式</li> <li><code>Type</code> 就是对象所属的类型，注意，是类型，不是对象所属的变量名</li> <li><code>Trait</code> 就是对象所实现的 trait 名称，使用 <code>as</code> 关键字，从而告知所调用的方法属于 <code>Trait</code> 而不是 <code>Type</code></li> <li><code>receiver</code> 就是 <code>self/&amp;self</code> ，最常见的 <code>obj.func()</code> 调用里，就是 rust 自动帮我们将 receiver (即 <code>self/&amp;self</code> ) 传入的</li> <li><code>arg</code> 是参数</li></ol> <h3 id="推演"><a href="#推演" class="header-anchor">#</a> 推演</h3> <blockquote><p>推演注意事项</p></blockquote> <ul><li>该问题的本质在于，如何区分开 <code>Type</code> 和 <code>Trait</code></li> <li>所以调用 <code>Fater/Grandpa</code> 的方式是一致的，下面的推演只在 <code>Child</code> 和 <code>Father</code> 之间进行</li> <li>其中，假设有 <code>let c = Child</code></li> <li>下面的推演过程中，打勾的表示语法正确，打叉的表示语法错误</li></ul> <blockquote><p>下面开始推演</p></blockquote> <ul><li><strong>调用 Child 的 with_self</strong> <ol><li>❌ 完全限定语法：<code>&lt;Child as Child&gt;::with_self(&amp;c)</code></li> <li>✅ <code>Child</code> 不是 Trait ，所以不能用 <code>as</code> ：<code>&lt;Child&gt;::with_self(&amp;c)</code></li> <li>✅ 既然不用 <code>as</code> ，所以 Child 本身已经是类型了：<code>Child::with_self(&amp;c)</code></li> <li>✅ 让 rust 自动传入 <code>&amp;c</code> 信息：<code>c.with_self()</code></li></ol></li> <li><strong>调用 Fater 的 with_self</strong> <ol><li>✅ 完全限定语法：<code>&lt;Child as Father&gt;::with_self(&amp;c)</code></li> <li>❌ <code>Fater</code> 是 <code>Trait</code> 而不是 <code>Type</code> ，所以不能省略 <code>as</code> ：<code>&lt;Father&gt;::with_self(&amp;c)</code></li> <li>✅ 由于有 <code>&amp;c</code> 信息，所以简化为：<code>Father::with_self(&amp;c)</code></li></ol></li> <li><strong>调用 Child 的 without_self</strong> <ol><li>❌ 完全限定语法：<code>&lt;Child as Child&gt;::without_self()</code></li> <li>✅ <code>Child</code> 不是 Trait ，所以不能用 <code>as</code> ：<code>&lt;Child&gt;::without_self()</code></li> <li>✅ 既然不用 <code>as</code> ，所以 Child 本身已经是类型了：<code>Child::without_self()</code></li> <li>❌ 让 rust 自动传入 <code>&amp;c</code> 信息时，发现参数不匹配：<code>c.without_self()</code></li></ol></li> <li><strong>调用 Fater 的 without_self</strong> <ol><li>✅ 完全限定语法：<code>&lt;Child as Father&gt;::without_self()</code></li> <li>❌ <code>Fater</code> 是 <code>Trait</code> 而不是 <code>Type</code> ，所以不能省略 <code>as</code> ：<code>&lt;Father&gt;::without_self()</code></li> <li>❌ 没有 <code>&amp;c</code> 信息，所以直接调用 <code>Trait</code> 方法错误：<code>Father::without_self()</code></li></ol></li></ul> <blockquote><p>下面就是所有正确的调用</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> Child<span class="token punctuation">;</span>

    <span class="token comment">/*
    运行结果均为：
    Child_with_self
    */</span>
    c<span class="token punctuation">.</span><span class="token function">with_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Child<span class="token punctuation">::</span><span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>Child<span class="token operator">&gt;</span><span class="token punctuation">::</span><span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
    运行结果均为：
    Father_with_self
    */</span>
    Father<span class="token punctuation">::</span><span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>Child <span class="token keyword">as</span> Father<span class="token operator">&gt;</span><span class="token punctuation">::</span><span class="token function">with_self</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/*
    运行结果均为：
    Child_without_self
    */</span>
    Child<span class="token punctuation">::</span><span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span>Child<span class="token operator">&gt;</span><span class="token punctuation">::</span><span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
    运行结果为：
    Father_without_self
    */</span>
    <span class="token operator">&lt;</span>Child <span class="token keyword">as</span> Father<span class="token operator">&gt;</span><span class="token punctuation">::</span><span class="token function">without_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h2 id="trait-依赖"><a href="#trait-依赖" class="header-anchor">#</a> trait 依赖</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <ul><li>与 C++ / Java 类似，一个类可以同时实现多个接口，而一个接口也可以同时依赖于另一个接口</li> <li>在 rust 中，一个 trait 可能依赖于一个或多个其它的 trait ，所依赖的这些 trait 叫 <em><strong>supertrait</strong></em></li> <li>例如，<code>trait Trait1 : SuperTrait1 + SuperTrait2</code></li> <li>注意，语法通过 <code>:</code> 表示依赖，通过 <code>+</code> 表示多个依赖</li> <li>那么，为某个 TYPE 实现 <code>Trait1</code> 时，这个 TYPE 就需要同时实现 <code>SuperTrait1</code> 和 <code>SuperTrait2</code></li> <li>因为，<code>Trait1</code> 中会使用到 <code>SuperTrait1</code> 和 <code>SuperTrait2</code> 里的方法（一般在 <code>Trait1</code> 的默认实现中）</li> <li>同时，对于该 TYPE 来说，也就同时具备了 <code>SuperTrait1</code> 和 <code>SuperTrait2</code> 的功能</li></ul> <h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h3> <p>要为某个 TYPE 实现如下打印功能：</p> <div class="language-text line-numbers-mode"><pre class="language-text"><code>&gt;&gt;6
**********
*        *
* (2, 3) *
*        *
**********
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>功能剖析：</p> <ol><li>首先，打印序号，例如  <code>6</code> ，该序号的生成通过 trait 来完成，叫做 <code>SerialNumber</code></li> <li>然后，打印该 TYPE 的内容，例如 <code>(2, 3)</code>，需要获得该 TYPE 的字符串表示，通过 trait 来完成，叫做 <code>ToString</code></li> <li>最后，进行格式化，包括 <code>&gt;&gt;</code> ，以及 <code>*</code> 等，由 trait 进行默认实现，叫做 <code>OutlinePrint</code></li> <li>那么，<code>OutlinePrint</code> 就依赖于 <code>SerialNumber</code> 和 <code>ToString</code></li> <li>要为 TYPE 实现 <code>OutlinePrint</code> 时，就需要同时实现 <code>SerialNumber</code> 和 <code>ToString</code></li></ol> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <blockquote><p>定义生成序号的 trait</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">trait</span> SerialNumber <span class="token punctuation">{</span>
    <span class="token comment">//获得序号，类型是 i32</span>
    <span class="token keyword">fn</span> <span class="token function">serial_number</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i32<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>定义转换为字符串的 trait</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">trait</span> ToString <span class="token punctuation">{</span>
    <span class="token comment">//获得类型对应的字符串</span>
    <span class="token keyword">fn</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>格式化 trait 的定义和默认实现</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token comment">//同时依赖 ToString 和 SerialNumber</span>
<span class="token keyword">trait</span> OutlinePrint <span class="token punctuation">:</span> ToString <span class="token operator">+</span> SerialNumber <span class="token punctuation">{</span>
    <span class="token comment">//实现了格式化方法</span>
    <span class="token keyword">fn</span> <span class="token function">outline_print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//获得序号值</span>
        <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">serial_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获得要格式化的内容</span>
        <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> len <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//格式化</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;&gt;&gt;{}&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;**{}**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;* {} *&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;* {} *&quot;</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;* {} *&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;**{}**&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>定义类型并实现上述 trait</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> Point <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> i32<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">//生成序号值，该例子中是 x*y</span>
<span class="token keyword">impl</span> SerialNumber <span class="token keyword">for</span> Point <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">serial_number</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> i32 <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//生成该类型的字符串表示，该例子中是 (x, y)</span>
<span class="token keyword">impl</span> ToString <span class="token keyword">for</span> Point <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> String <span class="token punctuation">{</span>
        <span class="token function">format!</span><span class="token punctuation">(</span><span class="token string">&quot;({}, {})&quot;</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//使用该 trait 的默认实现</span>
<span class="token keyword">impl</span> OutlinePrint <span class="token keyword">for</span> Point <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>测试</p></blockquote> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> Point <span class="token punctuation">{</span>
        x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> 
        y<span class="token punctuation">:</span> <span class="token number">4</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">/*
    调用该接口即可完成整个格式化过程，
    虽然格式化过程是通过多个trait组合实现的
    */</span>
    p<span class="token punctuation">.</span><span class="token function">outline_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>打印结果</p></blockquote> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token operator">&gt;&gt;</span><span class="token number">12</span>
**********
*        *
* <span class="token punctuation">(</span><span class="token number">3</span>, <span class="token number">4</span><span class="token punctuation">)</span> *
*        *
**********
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="newtype-模式"><a href="#newtype-模式" class="header-anchor">#</a> newtype 模式</h2> <h3 id="回顾"><a href="#回顾" class="header-anchor">#</a> 回顾</h3> <p>在 Chapter10 讲解 trait 的实现时，总结了 <em><strong>孤儿规则</strong></em>（<em><strong>orphan rule</strong></em>）：</p> <blockquote><ol><li>实现 trait 时，type 和 trait ，必须至少有一个 local to our crate</li> <li>例如，当前 crate 中有 <code>NewsArticle</code> 这个 type ，也有 <code>Summary</code> 这个 trait ，那么：
<ul><li>可以为 <code>NewsArticle</code> 实现标准库的 <code>Display</code> 这个 trait</li> <li>也可以为标准库的 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code> 这个 trait</li> <li>但不可以为标准库的 <code>Vec&lt;T&gt;</code> 实现标准库的 <code>Display</code> 这个 trait</li></ul></li> <li>这个约束叫做 <em><strong>coherence</strong></em> ，也叫 <em><strong>orphan rule</strong></em></li> <li>该约束的作用是，确保了别人不会破坏到我们的代码，反过来，也确保了我们不会破坏到别人的代码</li></ol></blockquote> <h3 id="使用-newtype"><a href="#使用-newtype" class="header-anchor">#</a> 使用 newtype</h3> <p>绕开 <em><strong>orphan rule</strong></em> 的方法：</p> <ul><li>例如，要在 <code>Vec&lt;T&gt;</code> 上实现 <code>Display</code></li> <li>则创建一个新类型（<em><strong>newtype</strong></em>），让这个新类型包含 <code>Vec&lt;T&gt;</code></li> <li>然后就可以在该新类型上实现 <code>Display</code> ，而且可以访问到 <code>Vec&lt;T&gt;</code> 的内容</li> <li>包装新类型时，最简单的方式就是 <em><strong>tuple struct</strong></em></li></ul> <p>例如：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>fmt<span class="token punctuation">;</span>

<span class="token comment">//用 tuple struct 包装 Vec&lt;String&gt;</span>
<span class="token keyword">struct</span> <span class="token function">Wrapper</span><span class="token punctuation">(</span>Vec<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//为新类型实现 Display</span>
<span class="token keyword">impl</span> fmt<span class="token punctuation">::</span>Display <span class="token keyword">for</span> Wrapper <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> fmt<span class="token punctuation">::</span>Formatter<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> fmt<span class="token punctuation">::</span>Result <span class="token punctuation">{</span>
        <span class="token comment">//注意：通过 self.0 来访问到 Vec&lt;String&gt;</span>
        <span class="token function">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">&quot;[{}]&quot;</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token function">Wrapper</span><span class="token punctuation">(</span><span class="token function">vec!</span><span class="token punctuation">[</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;w = {}&quot;</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>输出结果：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>w <span class="token operator">=</span> <span class="token punctuation">[</span>hello, world<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="问题-2"><a href="#问题-2" class="header-anchor">#</a> 问题</h3> <p><em><strong>newtype</strong></em> 的缺点是：</p> <ul><li>新类型 <code>w</code> 包装了值，但同时隐藏了值本身的方法</li> <li>例如，要像使用 <code>Vec&lt;T&gt;</code> 那样直接使用 <code>Wrapper</code> ，则必须直接在 <code>Wrapper</code> 上实现 <code>Vec&lt;T&gt;</code> 的所有方法</li></ul> <p>解决办法是：</p> <ul><li>通过 <code>self.0</code> 或者 <code>w.0</code> 来访问到 <code>Vec&lt;T&gt;</code> ，再进一步访问 <code>Vec&lt;T&gt;</code> 中的方法</li> <li>更好的办法是，为 <code>Wrapper</code> 实现 <code>Deref</code> 这个 trait（参考 Chapter15 ），并返回所包装的值类型（即 <code>Vec&lt;T&gt;</code> ）</li> <li>但是，如果要限制封装类型的行为，即不希望内部类型的方法被全部暴露出来，就只能自行实现所需的方法了</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">3/25/2020, 4:00:12 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Rust/Rust_Book_Exp/19 Advanced Features/01 Unsafe Rust.html" class="prev">
        19.1. 不安全代码
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.b639eb72.js" defer></script><script src="/assets/js/2.5df156af.js" defer></script><script src="/assets/js/91.8166ca11.js" defer></script>
  </body>
</html>
