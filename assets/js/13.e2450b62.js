(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{425:function(v,_,e){v.exports=e.p+"assets/img/01.8d861973.png"},554:function(v,_,e){"use strict";e.r(_);var t=e(27),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"对象切片的构造与析构法则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象切片的构造与析构法则"}},[v._v("#")]),v._v(" 对象切片的构造与析构法则")]),v._v(" "),t("p",[t("em",[v._v("本文对 C++ 多继承涉及到的构造、析构、切片等原理进行了剖析。")])]),v._v(" "),t("h2",{attrs:{id:"准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[v._v("#")]),v._v(" 准备")]),v._v(" "),t("p",[t("img",{attrs:{src:e(425),alt:"pic"}})]),v._v(" "),t("p",[v._v("注：上图不能表明多继承时的 "),t("em",[t("strong",[v._v("左右顺序")])]),v._v(" ，因此对于涉及到多继承的类，单独用代码描述如下：")]),v._v(" "),t("ul",[t("li",[v._v("public class "),t("code",[v._v("Child")]),v._v(" : public "),t("code",[v._v("ParentA")]),v._v(" , public "),t("code",[v._v("ParentB")]),v._v(" ;")]),v._v(" "),t("li",[v._v("Public class "),t("code",[v._v("ParentA1")]),v._v(" : public "),t("code",[v._v("ParentAA2")]),v._v(" , public "),t("code",[v._v("ParentA2")]),v._v(" ;")]),v._v(" "),t("li",[v._v("public class "),t("code",[v._v("ParentB1")]),v._v(" : public "),t("code",[v._v("ParentBB2")]),v._v(" , public "),t("code",[v._v("ParentB2")]),v._v(" ;")])]),v._v(" "),t("p",[v._v("根据改图可以看到，存在多棵继承树，每棵树 "),t("em",[t("strong",[v._v("从上到下")])]),v._v(" 描述为：")]),v._v(" "),t("ul",[t("li",[v._v("ParentAA2, ParentA1, ParentA, Child")]),v._v(" "),t("li",[v._v("ParentA2, ParentA1, ParentA, Child")]),v._v(" "),t("li",[v._v("ParentBB2, ParentB1, ParentB, Child")]),v._v(" "),t("li",[v._v("ParentB2, ParentB1, ParentB, Child")])]),v._v(" "),t("h2",{attrs:{id:"构造与析构的顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造与析构的顺序"}},[v._v("#")]),v._v(" 构造与析构的顺序")]),v._v(" "),t("p",[v._v("有如下代码：")]),v._v(" "),t("div",{staticClass:"language-cpp line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[v._v("Child"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" c "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("Child")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("delete")]),v._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br")])]),t("blockquote",[t("p",[v._v("构造顺序原则：")])]),v._v(" "),t("ul",[t("li",[v._v("先构造该对象的继承树，如果有多棵树，则按照类声明的顺序，"),t("em",[t("strong",[v._v("从左到右")])]),v._v(" 依次构造每一棵继承树；")]),v._v(" "),t("li",[v._v("对于一棵继承树，总是从从树顶开始，依次向下完成构造，即 "),t("em",[t("strong",[v._v("从上到下")])]),v._v(" ；")])]),v._v(" "),t("blockquote",[t("p",[v._v("构造顺序剖析（从上到下的顺序，其中代码引用的部分表明实际发生了构造行为）：")])]),v._v(" "),t("ul",[t("li",[v._v("构造 Child 之前，发现 Child 有两棵继承树，从左到右是 ParentA 和 ParentB")]),v._v(" "),t("li",[v._v("所以先构造 ParentA 这棵树")]),v._v(" "),t("li",[v._v("构造 ParentA 这棵树时，向上攀爬依次找到 ParentA 、ParentA1")]),v._v(" "),t("li",[v._v("发现 ParentA1 有两棵继承树，从左到右是 ParentAA2 和 ParentA2")]),v._v(" "),t("li",[v._v("所以先构造 ParentAA2 这棵树，再构造 ParentA2 这棵树")]),v._v(" "),t("li",[v._v("ParentAA2 已经是树顶，所以有："),t("code",[v._v("ParentAA2()")])]),v._v(" "),t("li",[v._v("ParentA2 已经是树顶，所以有："),t("code",[v._v("ParentA2()")])]),v._v(" "),t("li",[v._v("向下回到 ParentA1() ，所以有："),t("code",[v._v("ParentA1()")])]),v._v(" "),t("li",[v._v("再向下回到 ParentA() ，所以有："),t("code",[v._v("ParentA()")])]),v._v(" "),t("li",[v._v("此时再构造 ParentB 这棵树")]),v._v(" "),t("li",[v._v("构造 ParentB 这棵树时，向上攀爬依次找到 ParentB 、ParentB1")]),v._v(" "),t("li",[v._v("发现 ParentB1 有两棵继承树，从左到右是 ParentBB2 和 ParentB2")]),v._v(" "),t("li",[v._v("所以先构造 ParentBB2 这棵树，再构造 ParentB2 这棵树")]),v._v(" "),t("li",[v._v("ParentBB2 已经是树顶，所以有："),t("code",[v._v("ParentBB2()")])]),v._v(" "),t("li",[v._v("ParentB2 已经是树顶，所以有："),t("code",[v._v("ParentB2()")])]),v._v(" "),t("li",[v._v("向下回到 ParentB1，所以有："),t("code",[v._v("ParentB1()")])]),v._v(" "),t("li",[v._v("再向下回到 ParentB，所以有："),t("code",[v._v("ParentB()")])]),v._v(" "),t("li",[v._v("此时 Child 的两棵继承树已经构造完毕")]),v._v(" "),t("li",[v._v("因此该构造 Child ，所以有："),t("code",[v._v("Child()")])])]),v._v(" "),t("blockquote",[t("p",[v._v("析构顺序原则：")])]),v._v(" "),t("ul",[t("li",[v._v("系统以 "),t("em",[t("strong",[v._v("当前所析构的对象")])]),v._v(" 为基准，按照 "),t("em",[t("strong",[v._v("与构造时相反")])]),v._v(" 的顺序依次进行；")]),v._v(" "),t("li",[v._v("也就是说，系统所析构的内容只包括 "),t("em",[t("strong",[v._v("该对象及对象上方的所有继承树")])]),v._v(" ，而不包括该对象下方的所有继承树；")])]),v._v(" "),t("blockquote",[t("p",[v._v("析构顺序剖析：")])]),v._v(" "),t("ul",[t("li",[v._v("与构造的顺序完全相反即可；")])]),v._v(" "),t("h2",{attrs:{id:"切片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#切片"}},[v._v("#")]),v._v(" 切片")]),v._v(" "),t("p",[v._v("按照面向对象的切片规则，Child 对象是可以被其继承树 "),t("em",[t("strong",[v._v("上方")])]),v._v(" 的任何一个类型接收的，即可以有如下代码：")]),v._v(" "),t("div",{staticClass:"language-cpp line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[v._v("ParentXX"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" ps "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("Child")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("p",[v._v("其中 "),t("code",[v._v("ParentXX")]),v._v(" 具体类型可以是：")]),v._v(" "),t("ul",[t("li",[v._v("ParentA, ParentA1, ParentA2, ParentAA2")]),v._v(" "),t("li",[v._v("ParentB, ParentB1, ParentB2, ParentBB2")])]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("按照切片规则，此时 "),t("code",[v._v("ParentXX")]),v._v(" 所保留的信息只是实际对象的一个子集，并不是全部；")]),v._v(" "),t("li",[v._v("后续开始讲解，直接 "),t("em",[t("strong",[v._v("析构")])]),v._v(" 一个切片时，实际会发生什么")])])]),v._v(" "),t("div",{staticClass:"language-cpp line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("delete")]),v._v(" ps"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("h2",{attrs:{id:"切片的析构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#切片的析构"}},[v._v("#")]),v._v(" 切片的析构")]),v._v(" "),t("blockquote",[t("p",[v._v("原则")])]),v._v(" "),t("ul",[t("li",[v._v("切片本身也是一个对象，虽其并未包含真实的内存对象的全部")]),v._v(" "),t("li",[v._v("因此，直接析构一个切片时，仍然遵循上述总结的析构顺序")]),v._v(" "),t("li",[v._v("也就是说，系统仍然会以当前切片为基准，将该 "),t("em",[t("strong",[v._v("切片及切片上方的继承树")])]),v._v(" 析构完毕")]),v._v(" "),t("li",[v._v("但是，该 "),t("em",[t("strong",[v._v("切片之下")])]),v._v(" 的部分，将无法被析构")])]),v._v(" "),t("blockquote",[t("p",[v._v("问题")])]),v._v(" "),t("ul",[t("li",[v._v("由此可见，如果析构的是真实对象本身，则一切运转正常")]),v._v(" "),t("li",[v._v("但如果对象仅仅被一个切片的形式析构，必然造成内存泄露或者内存错误")])]),v._v(" "),t("blockquote",[t("p",[v._v("解决")])]),v._v(" "),t("ul",[t("li",[v._v("无论是析构切片，还是析构真实对象本身，解决目标是：让系统定位到要析构的那个 "),t("em",[t("strong",[v._v("真实对象")])]),v._v(" ，而不是只定位到某个切片；")]),v._v(" "),t("li",[v._v("所以，这就是 "),t("code",[v._v("virtual")]),v._v(" 析构器的魅力；")])]),v._v(" "),t("h2",{attrs:{id:"virtual-析构器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-析构器"}},[v._v("#")]),v._v(" virtual 析构器")]),v._v(" "),t("blockquote",[t("p",[v._v("virtual 析构器的作用：")])]),v._v(" "),t("ul",[t("li",[v._v("用 "),t("code",[v._v("virtual")]),v._v(" 来修饰一个对象/切片的析构器时，可改变系统的析构行为：\n"),t("ul",[t("li",[v._v("从该对象/切片 "),t("em",[t("strong",[v._v("向下")])]),v._v(" 追溯并定位到真实的那个内存对象")]),v._v(" "),t("li",[v._v("然后以这个真实的内存对象为基准，来开始进行析构")]),v._v(" "),t("li",[v._v("也就是说，这样的析构过程才是正确且干净的")])])]),v._v(" "),t("li",[v._v("举例：我们直接 "),t("code",[v._v("delete")]),v._v(" 切片 "),t("code",[v._v("ParentAA2")]),v._v(" ：\n"),t("ul",[t("li",[v._v("则只要 "),t("code",[v._v("ParentAA2")]),v._v(" 的析构器使用了 "),t("code",[v._v("virtual")]),v._v(" 修饰，系统就能够从 "),t("code",[v._v("ParentAA2")]),v._v(" "),t("em",[t("strong",[v._v("向下")])]),v._v(" 回溯，定位到真实的内存对象，即 "),t("code",[v._v("Child")]),v._v(" 对象")]),v._v(" "),t("li",[v._v("然后按照前面所讲解的析构顺序，开始 "),t("code",[v._v("Child")]),v._v(" 对象的析构过程")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("virtual 析构器的彩蛋：")])]),v._v(" "),t("ul",[t("li",[v._v("同一棵继承树上，并非所有切片都需要 "),t("code",[v._v("virtual")]),v._v(" 修饰：\n"),t("ul",[t("li",[v._v("在上面的多继承树示意图里，从 "),t("code",[v._v("Child")]),v._v(" 对象开始，可以有很多切片")]),v._v(" "),t("li",[v._v("但并非每个切片类型的析构器都必须用 "),t("code",[v._v("virtual")]),v._v(" 修饰")]),v._v(" "),t("li",[v._v("我们只需保证：被 "),t("code",[v._v("delete")]),v._v(" 的切片及该切片 "),t("em",[t("strong",[v._v("上方")])]),v._v(" 的继承树里，有 "),t("em",[t("strong",[v._v("至少一个")])]),v._v(" 节点的析构器使用了 "),t("code",[v._v("virtual")]),v._v(" 修饰")]),v._v(" "),t("li",[v._v("则在 "),t("code",[v._v("delete")]),v._v(" 该切片时，系统就能够 "),t("em",[t("strong",[v._v("向下")])]),v._v(" 回溯并定位到真实的 "),t("code",[v._v("Child")]),v._v(" 对象，从而进行正确且干净的析构")])])]),v._v(" "),t("li",[v._v("举例：我们直接 "),t("code",[v._v("delete")]),v._v(" 切片 "),t("code",[v._v("ParentA")]),v._v(" ：\n"),t("ul",[t("li",[t("code",[v._v("ParentA")]),v._v(" 没有使用 "),t("code",[v._v("virtual")]),v._v(" 修饰")]),v._v(" "),t("li",[t("code",[v._v("ParentA")]),v._v(" 上方的继承树里，只有 "),t("code",[v._v("ParentAA2")]),v._v(" 的析构器使用了 "),t("code",[v._v("virtual")]),v._v(" 修饰")]),v._v(" "),t("li",[v._v("则 "),t("code",[v._v("delete ParentA")]),v._v(" 时，系统仍然能够定位到真实的 "),t("code",[v._v("Child")]),v._v(" 对象完成析构")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("virtual 析构器的陷阱：")])]),v._v(" "),t("ul",[t("li",[v._v("对于上面描述的彩蛋，在不交叉的继承树之间不适用：\n"),t("ul",[t("li",[v._v("在上面的多继承树示意图里，虽然能够数出多棵继承树，但有的继承树之间是不交叉的")]),v._v(" "),t("li",[v._v("例如，"),t("code",[v._v("ParentA1")]),v._v(" 与 "),t("code",[v._v("ParentB1")]),v._v(" 这两个节点所属的继承树是相互独立的")]),v._v(" "),t("li",[v._v("所以，彩蛋只适用于同一棵继承树")])])]),v._v(" "),t("li",[v._v("举例：我们直接 "),t("code",[v._v("delete")]),v._v(" 切片 "),t("code",[v._v("ParentB")]),v._v(" ：\n"),t("ul",[t("li",[v._v("整个多继承树示意图里，只有 "),t("code",[v._v("ParentAA2")]),v._v(" 的析构器使用了 "),t("code",[v._v("virtual")]),v._v(" 修饰")]),v._v(" "),t("li",[t("code",[v._v("ParentB")]),v._v(" 上方的继承树里，找不到任何一个 "),t("code",[v._v("virtual")]),v._v(" 修饰的析构器")]),v._v(" "),t("li",[v._v("因为 "),t("code",[v._v("ParentAA2")]),v._v(" 与 "),t("code",[v._v("ParentB")]),v._v(" 不在同一棵继承树上")]),v._v(" "),t("li",[v._v("则 "),t("code",[v._v("delete ParentB")]),v._v(" 时，系统将只能基于 "),t("code",[v._v("ParentB")]),v._v(" 这个切片来析构，将产生内存问题")])])])]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("ul",[t("li",[v._v("用 "),t("code",[v._v("virtual")]),v._v(" 修饰析构器应当成为一种编程习惯")]),v._v(" "),t("li",[v._v("C++ 的默认析构器（即不显式定义析构器）是没有 "),t("code",[v._v("virtual")]),v._v(" 修饰的")]),v._v(" "),t("li",[v._v("在 "),t("code",[v._v("delete")]),v._v(" 一个切片时，可能的情况下，最安全的做法是：\n"),t("ul",[t("li",[v._v("先将该切片转换为真实的内存对象类型，然后再析构该真实内存对象类型")]),v._v(" "),t("li",[v._v("而不是直接析构该切片，以防切片及切片上方的继承树中没有 "),t("code",[v._v("virtual")]),v._v(" 析构器")])])]),v._v(" "),t("li",[v._v("关于 "),t("code",[v._v("interface")]),v._v(" 切片要注意：\n"),t("ul",[t("li",[v._v("C++ 只有 "),t("code",[v._v("class")]),v._v(" 的概念，而所谓的 "),t("code",[v._v("interface")]),v._v(" 其实只是将 "),t("code",[v._v("class")]),v._v(" 里的方法都修饰为纯虚函数，因此 "),t("code",[v._v("interface")]),v._v(" 本身也是一个类")]),v._v(" "),t("li",[v._v("但 "),t("code",[v._v("interface")]),v._v(" 除了对方法进行纯虚抽象之外，「干净整洁」也是价值之一，所以很难容忍在 "),t("code",[v._v("interface")]),v._v(" 中增加一个空的 "),t("code",[v._v("virtual")]),v._v("析构器")]),v._v(" "),t("li",[v._v("所以，一定要当心直接 "),t("code",[v._v("delete")]),v._v(" 该 "),t("code",[v._v("interface")]),v._v(" 切片类型可能带来的内存问题")])])])]),v._v(" "),t("h2",{attrs:{id:"拓展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[v._v("#")]),v._v(" 拓展")]),v._v(" "),t("p",[v._v("既然 "),t("code",[v._v("virtual")]),v._v(" 析构器这么优秀，为何 C++ 的析构器不默认为 "),t("code",[v._v("virtual")]),v._v(" 修饰呢？因为 "),t("code",[v._v("virtual")]),v._v(" 是一个运行时体系，涉及到运行时成本。具体可参考另一篇文章："),t("a",{attrs:{href:"/C++/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/%E4%BB%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90C++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6"}},[v._v("从内存模型分析C++的面向对象机制")])])])}),[],!1,null,null,null);_.default=a.exports}}]);