(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{487:function(l,v,_){"use strict";_.r(v);var t=_(27),a=Object(t.a)({},(function(){var l=this,v=l.$createElement,_=l._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h1",{attrs:{id:"网络编程概念汇总"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络编程概念汇总"}},[l._v("#")]),l._v(" 网络编程概念汇总")]),l._v(" "),_("p",[_("em",[l._v("根据学习网络上大量的碎片知识，进行汇总和梳理。")])]),l._v(" "),_("h2",{attrs:{id:"阻塞-非阻塞-io多路复用-异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-非阻塞-io多路复用-异步"}},[l._v("#")]),l._v(" 阻塞/非阻塞/IO多路复用/异步")]),l._v(" "),_("h3",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[l._v("#")]),l._v(" 基础")]),l._v(" "),_("p",[l._v("它们并不是独立存在的多种网络I/O，只是描述的方式不同而已。首先明确基础概念：")]),l._v(" "),_("ol",[_("li",[_("p",[l._v("进行网络I/O时，例如读、写，存在两个基本动作：")]),l._v(" "),_("ul",[_("li",[l._v("判断是否就绪，例如当前是否有数据到达，从而可读；")]),l._v(" "),_("li",[l._v("数据就绪后，将数据读出，进行后续处理；")])])]),l._v(" "),_("li",[_("p",[l._v("网络I/O操作在操作系统中存在两个层面的切换：")]),l._v(" "),_("ul",[_("li",[l._v("内核层，进行I/O状态判断，数据读写等；")]),l._v(" "),_("li",[l._v("用户层，对内核层进行状态判断、数据读写的请求操作等；")])])])]),l._v(" "),_("h3",{attrs:{id:"阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阻塞"}},[l._v("#")]),l._v(" 阻塞")]),l._v(" "),_("ol",[_("li",[l._v("发起IO请求，开始阻塞；")]),l._v(" "),_("li",[l._v("等待内核层状态就绪；")]),l._v(" "),_("li",[l._v("状态就绪后拷贝数据到用户层；")]),l._v(" "),_("li",[l._v("阻塞结束；")])]),l._v(" "),_("h3",{attrs:{id:"非阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞"}},[l._v("#")]),l._v(" 非阻塞")]),l._v(" "),_("ol",[_("li",[l._v("发起IO请求，立即返回；")]),l._v(" "),_("li",[l._v("不断的主动询问内核层状态是否就绪；")]),l._v(" "),_("li",[l._v("若状态就绪，拷贝数据到用户层；")])]),l._v(" "),_("h3",{attrs:{id:"io多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[l._v("#")]),l._v(" IO多路复用")]),l._v(" "),_("ol",[_("li",[l._v("针对非阻塞的方式进行改进，因为非阻塞方式需要主动的不断询问内核层状态，当fd较多时不便于处理；")]),l._v(" "),_("li",[l._v("将要处理的多个fd交给内核层，内核层同时查看多个fd是否有就绪的，而用户层阻塞；")]),l._v(" "),_("li",[l._v("若有就绪的fd则结束阻塞，用户层针对就绪的fd进行处理；")])]),l._v(" "),_("h3",{attrs:{id:"异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[l._v("#")]),l._v(" 异步")]),l._v(" "),_("ol",[_("li",[l._v("用户层发起IO请求，立即返回；")]),l._v(" "),_("li",[l._v("内核层自行等待状态就绪并处理数据例如拷贝；")]),l._v(" "),_("li",[l._v("结束后发起回调，告知用户层；")])]),l._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[l._v("#")]),l._v(" 总结")]),l._v(" "),_("ol",[_("li",[l._v("看似术语很多，其实只有三种：阻塞，非阻塞，异步；")]),l._v(" "),_("li",[l._v("IO多路复用只是针对非阻塞的改进方式，例如select,poll,epoll；其中epoll是linux提供的方式；")]),l._v(" "),_("li",[l._v("异步只有Windows的IOCP做了很好的实现；")]),l._v(" "),_("li",[l._v("所谓的同步和异步，就看如何理解:\n"),_("ul",[_("li",[l._v("可以认为阻塞、非阻塞、IO多路复用都是同步，因为同步过程要不是等待内核层数据就绪（例如阻塞），要不就是从内核层同步的拷贝数据（例如非阻塞）；")]),l._v(" "),_("li",[l._v("也可以认为只有阻塞式是同步，其它的都是异步；")]),l._v(" "),_("li",[l._v("也可以认为只有Windows的IOCP才是异步，其它的都是同步；")])])])]),l._v(" "),_("h2",{attrs:{id:"select-poll-epoll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#select-poll-epoll"}},[l._v("#")]),l._v(" select/poll/epoll")]),l._v(" "),_("p",[l._v("都是IO多路复用的方式，只有Windows的IOCP是真正的异步IO，因此详细说明几种IO多路复用的区别。")]),l._v(" "),_("h3",{attrs:{id:"select"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[l._v("#")]),l._v(" select")]),l._v(" "),_("ol",[_("li",[l._v("使用数组存储fd，个数有限制，32位系统是1024个，64位系统是2048个；")]),l._v(" "),_("li",[l._v("每次进行select时，将fd全部拷贝进内核层；")]),l._v(" "),_("li",[l._v("内核层将所有的fd遍历一遍，针对就绪的fd，设置对应就绪标记，例如读，写，错误等；")]),l._v(" "),_("li",[l._v("若都没有任何fd就绪，则阻塞并睡眠一段时间后继续轮询；")]),l._v(" "),_("li",[l._v("有任何fd就绪，则返回；")]),l._v(" "),_("li",[l._v("所以轮询fd的时间复杂度是O(n)；")])]),l._v(" "),_("h3",{attrs:{id:"poll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[l._v("#")]),l._v(" poll")]),l._v(" "),_("ol",[_("li",[l._v("使用链表存储fd，因此个数没有限制；")]),l._v(" "),_("li",[l._v("其它方面和原理包括时间复杂度都与select完全相同；")])]),l._v(" "),_("h3",{attrs:{id:"epoll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[l._v("#")]),l._v(" epoll")]),l._v(" "),_("ol",[_("li",[l._v("epoll的意思就是event poll，是对poll的改进；")]),l._v(" "),_("li",[l._v("不用重复拷贝全部fd进内核层，而是在有新的fd时，挂接进内核层；")]),l._v(" "),_("li",[l._v("因此fd的存储空间是内核层和用户层共享的一片内存；")]),l._v(" "),_("li",[l._v("对于fd的个数也没有限制；")]),l._v(" "),_("li",[l._v("内核层会为每个fd指定一个回调，在该fd就绪时，回调被触发，然后把fd放到一个就绪链表中；")]),l._v(" "),_("li",[l._v("从而epoll的时候，内核层不是在轮询所有fd，而是只轮询就绪链表；")]),l._v(" "),_("li",[l._v("因此针对就绪fd的查询上，时间复杂度为O(1)；因为某个fd就绪时会自动被加入到就绪链表中，从而epoll立即检测到有就绪的fd；")]),l._v(" "),_("li",[l._v("但是，如果活跃的fd很多，那么就绪链表也会增大，从而影响性能，因此针对这个问题，epoll提供LT和ET，即水平触发和边缘触发两种方式；")]),l._v(" "),_("li",[l._v("水平触发的意思是，只要就绪的fd未被处理，则会重复触发，所以如果就绪链表增大，那么性能也会收到影响；")]),l._v(" "),_("li",[l._v("边缘触发的意思是，就绪的fd只会被触发一次，直到第二次就绪状态到达，从而用户层可以只处理自己关心的fd；")])]),l._v(" "),_("h3",{attrs:{id:"总结-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[l._v("#")]),l._v(" 总结")]),l._v(" "),_("ol",[_("li",[l._v("关于fd在内核层与用户层之间的重复拷贝和挂接：selecet和poll每次调用时都需要重复拷贝和挂接fd，但epoll针对每个fd只需要拷贝和挂接一次；")]),l._v(" "),_("li",[l._v("关于fd在内核层与用户层之间的内存关系：select和poll每次调用时都需要将用户层的fd内存拷贝到内核层的fd内存，而epoll则在内核层和用户层之间共享fd内存，用户层只需要将新的fd挂接到该共享的内存中；")]),l._v(" "),_("li",[l._v("关于fd的轮询方式：select和poll轮询的是所有的fd，时间复杂度是O(n)，epoll中由fd就绪时会自动触发回调进而被加入就绪链表，因此时间复杂度是O(1)，所以epoll轮询的是就绪的fd而不是全部fd；")]),l._v(" "),_("li",[l._v("关于fd的存储方式：select使用数组，大小有限制，32位系统是1024，64位系统是2048；poll和epoll都使用链表的方式，大小理论上没有限制；")])]),l._v(" "),_("h2",{attrs:{id:"reactor-proactor"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor-proactor"}},[l._v("#")]),l._v(" Reactor/Proactor")]),l._v(" "),_("h3",{attrs:{id:"reactor"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor"}},[l._v("#")]),l._v(" Reactor")]),l._v(" "),_("ol",[_("li",[l._v("也叫反应器；")]),l._v(" "),_("li",[l._v("大致思路是，用户为fd注册所关心的事件，例如可读事件，可写事件；")]),l._v(" "),_("li",[l._v("然后Reactor进行事件轮询，有任何fd的任何事件发生时，就调用用户所设置的对应的处理方法；")]),l._v(" "),_("li",[l._v("用户的处理方法开始进行读、写等操作；")])]),l._v(" "),_("h3",{attrs:{id:"proactor"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#proactor"}},[l._v("#")]),l._v(" Proactor")]),l._v(" "),_("ol",[_("li",[l._v("也叫前摄式，或者主动器；")]),l._v(" "),_("li",[l._v("大致思路是，用户为fd发起对应的操作，例如读操作，或者写操作；")]),l._v(" "),_("li",[l._v("每个操作都是异步的，对应的每个操作都有一个完成后的回调；")]),l._v(" "),_("li",[l._v("然后Proactor管理完成事件队列，并分发这些完成事件，也就是调用用户的回调；")])]),l._v(" "),_("h3",{attrs:{id:"总结-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结-3"}},[l._v("#")]),l._v(" 总结")]),l._v(" "),_("ol",[_("li",[l._v("被动和主动：Reactor是被动的，在状态就绪时进行对应的操作；Proactor是主动的，主动发起操作，在就绪并操作完成后，处理最终的完成回调；")]),l._v(" "),_("li",[l._v("串行和并发：Reactor在一个反应器内，所有操作都是串行的，例如一个Reactor内监听了多个fd的多个事件，则所有fd的所有事件都是串行也就是同步的响应的；Proactor则可以异步也就是并发的发起多个fd的多个操作，然后每个fd的每个操作完成事件都单独响应；")]),l._v(" "),_("li",[l._v("简单和复杂：Reactor的事件处理可以理解为单线程顺序执行的，不用考虑并发加锁等问题，Proactor由于响应是异步的，处理要相对复杂一些；")]),l._v(" "),_("li",[l._v("时间和性能：Reactor的在事件响应操作时不能耗时太长，否则会影响其它fd和事件的响应，Proactor由于是异步的，可以处理耗时较长的任务；")])]),l._v(" "),_("h3",{attrs:{id:"再次总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#再次总结"}},[l._v("#")]),l._v(" 再次总结")]),l._v(" "),_("ol",[_("li",[l._v("Reactor和Proactor只是一种IO设计模式，注意是软件设计模式，与操作系统提供的IO处理方式是没有直接联系的；")]),l._v(" "),_("li",[l._v("例如，libevent框架、libuv框架，使用Reactor模式，使用了操作系统的select/poll机制，在linux下也使用了epoll，而在windows下，也有针对iocp的实现；")]),l._v(" "),_("li",[l._v("例如，ACE框架，提供了Reactor模式，也提供了Proactor模式；")]),l._v(" "),_("li",[l._v("例如，ASIO框架，使用Proactor模式，但在linux下使用epoll来包装，而windows下则使用IOCP；")]),l._v(" "),_("li",[l._v("所以，针对不同的操作系统提供的IO机制，都可以进行Reactor或者Proactor模式的设计，比如ACE，使用Reactor或者Proactor模式的时候，不用关心ACE内部是如何实现的，而ACE可以利用不同的操作系统下最优的IO机制；")]),l._v(" "),_("li",[l._v("前述总结的Reactor或者Proactor的优缺点和不同，并不是绝对的，比如，“Reactor的在事件响应操作时不能耗时太长，否则会影响其它fd和事件的响应”，实际场景中可能在读事件到达后，进行数据读取，然后放入另一个逻辑线程中进行后续处理；")]),l._v(" "),_("li",[l._v("所以，两种设计模式的采用是需要根据实际场景，进行复杂度和性能的综合权衡；")]),l._v(" "),_("li",[l._v("同理，要直接调用系统提供的IO机制的API，例如select/poll/epoll/iocp，还是要采用一些网络框架，例如libevent，libuv，ACE，也取决于复杂度、性能、场景的考量；")])])])}),[],!1,null,null,null);v.default=a.exports}}]);