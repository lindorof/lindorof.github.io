(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{437:function(e,l,o){e.exports=o.p+"assets/img/01.fcb1407b.jpg"},438:function(e,l,o){e.exports=o.p+"assets/img/02.c2bfaf6d.jpg"},439:function(e,l,o){e.exports=o.p+"assets/img/03.19f7d846.jpg"},440:function(e,l,o){e.exports=o.p+"assets/img/05.e8d324f0.jpg"},441:function(e,l,o){e.exports=o.p+"assets/img/06.b07a5622.jpg"},488:function(e,l,o){"use strict";o.r(l);var s=o(27),i=Object(s.a)({},(function(){var e=this,l=e.$createElement,s=e._self._c||l;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"unix网络io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unix网络io模型"}},[e._v("#")]),e._v(" UNIX网络IO模型")]),e._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),s("h3",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[e._v("#")]),e._v(" 参考文献")]),e._v(" "),s("ul",[s("li",[e._v("『UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking 』，Richard Stevens，6.2节，「I/O Models」")])]),e._v(" "),s("h3",{attrs:{id:"五种-io-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五种-io-model"}},[e._v("#")]),e._v(" 五种 IO Model")]),e._v(" "),s("p",[e._v("Stevens在文章中一共比较了五种 IO Model ：")]),e._v(" "),s("ul",[s("li",[e._v("blocking IO")]),e._v(" "),s("li",[e._v("nonblocking IO")]),e._v(" "),s("li",[e._v("IO multiplexing")]),e._v(" "),s("li",[e._v("signal driven IO （本文未讲解）")]),e._v(" "),s("li",[e._v("asynchronous IO")])]),e._v(" "),s("h3",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[e._v("#")]),e._v(" 基础")]),e._v(" "),s("blockquote",[s("p",[e._v("对于一个network IO (例如read)，会涉及两个系统对象：")])]),e._v(" "),s("ol",[s("li",[e._v("调用这个IO的process (or thread)")]),e._v(" "),s("li",[e._v("系统内核(kernel)")])]),e._v(" "),s("blockquote",[s("p",[e._v("当一个read操作发生时，会经历两个阶段：")])]),e._v(" "),s("ol",[s("li",[e._v("等待数据准备 (Waiting for the data to be ready)")]),e._v(" "),s("li",[e._v("将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)")])]),e._v(" "),s("h2",{attrs:{id:"blocking-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blocking-io"}},[e._v("#")]),e._v(" blocking IO")]),e._v(" "),s("p",[s("img",{attrs:{src:o(437),alt:"img"}})]),e._v(" "),s("ol",[s("li",[e._v("process调用recvfrom")]),e._v(" "),s("li",[e._v("kernel开始IO的第一个阶段，即准备数据")]),e._v(" "),s("li",[e._v("对于network io来说，可能数据还未到达，例如还未收到一个完整的UDP包")]),e._v(" "),s("li",[e._v("因此kernel开始需要等待足够的数据到来")]),e._v(" "),s("li",[e._v("对于process来说就被阻塞")]),e._v(" "),s("li",[e._v("kernel一直等到数据准备完毕")]),e._v(" "),s("li",[e._v("kernel将数据从kernel拷贝到用户内存并返回结果")]),e._v(" "),s("li",[e._v("process解除block状态")]),e._v(" "),s("li",[e._v("所以，blocking IO的特点就是在IO执行的两个阶段都被block了")])]),e._v(" "),s("h2",{attrs:{id:"non-blocking-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#non-blocking-io"}},[e._v("#")]),e._v(" non-blocking IO")]),e._v(" "),s("p",[s("img",{attrs:{src:o(438),alt:"img"}})]),e._v(" "),s("ol",[s("li",[e._v("process调用recvfrom")]),e._v(" "),s("li",[e._v("kernel数据还未准备好")]),e._v(" "),s("li",[e._v("kernal不会block process，而是立即返回error")]),e._v(" "),s("li",[e._v("process的调用立即返回并得到一个结果")]),e._v(" "),s("li",[e._v("process判断结果是error，则知道数据还未准备好")]),e._v(" "),s("li",[e._v("process从而可以再次发送recvform")]),e._v(" "),s("li",[e._v("kernel的数据已准备完毕，并再次收到了process的recvfrom")]),e._v(" "),s("li",[e._v("kernel立即将数据拷贝到用户内存并返回")]),e._v(" "),s("li",[e._v("所以，process需要不断的主动询问kernel数据是否准备完毕")])]),e._v(" "),s("h2",{attrs:{id:"io-multiplexing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io-multiplexing"}},[e._v("#")]),e._v(" IO multiplexing")]),e._v(" "),s("p",[s("img",{attrs:{src:o(439),alt:"img"}})]),e._v(" "),s("ol",[s("li",[e._v("IO multiplexing即select/epoll")]),e._v(" "),s("li",[e._v("process调用select，被block")]),e._v(" "),s("li",[e._v("kernel会监视select的所有socket")]),e._v(" "),s("li",[e._v("任何一个socket的数据准备完毕时，select就会返回")]),e._v(" "),s("li",[e._v("此时process再调用read，将数据从kernel拷贝到用户内存")]),e._v(" "),s("li",[e._v("blocking IO只需要调用一个system call (recvfrom)，但IO multiplexing需要调用两个system call (select和recvfrom)")]),e._v(" "),s("li",[e._v("select的优势是可以同时处理多个connection")]),e._v(" "),s("li",[e._v("若连接数不高时，select/epoll不比multi-threading + blocking IO性能更好")]),e._v(" "),s("li",[e._v("select/epoll的优势并不是对单个连接处理更快，而是能处理更多连接")]),e._v(" "),s("li",[e._v("实际使用IO multiplexing时，一般将每个socket都设置成为non-blocking，但process仍然被select所block，而不是被socket IO所block")])]),e._v(" "),s("h2",{attrs:{id:"asynchronous-io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-io"}},[e._v("#")]),e._v(" asynchronous IO")]),e._v(" "),s("p",[s("img",{attrs:{src:o(440),alt:"img"}})]),e._v(" "),s("ol",[s("li",[e._v("process调用recvfrom")]),e._v(" "),s("li",[e._v("kernel立即返回，不会block process")]),e._v(" "),s("li",[e._v("kernel等待数据准备完毕，然后将数据拷贝到用户内存")]),e._v(" "),s("li",[e._v("kernal向process发送signal，以告知read完成")])]),e._v(" "),s("h2",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),s("ol",[s("li",[e._v("blocking IO会一直block住对应的进程直到操作完成")]),e._v(" "),s("li",[e._v("non-blocking IO在kernel还未准备好数据的情况下会立刻返回")]),e._v(" "),s("li",[e._v("synchronous IO做「IO operation」的时候会将process阻塞")]),e._v(" "),s("li",[e._v("asynchronous IO在发起IO操作之后到「IO operation」完成都不会block process")]),e._v(" "),s("li",[e._v("所以可分类为：\n"),s("ul",[s("li",[e._v("asynchronous IO")]),e._v(" "),s("li",[e._v("synchronous IO (blocking IO，non-blocking IO，IO multiplexing)")])])]),e._v(" "),s("li",[e._v("其实不必纠结于分类，有的文献中就认为asynchronous IO和non-blocking IO是一个东西")])]),e._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[s("img",{attrs:{src:o(441),alt:"img"}})]),e._v(" "),s("ol",[s("li",[e._v("non-blocking IO和asynchronous IO区别很明显")]),e._v(" "),s("li",[e._v("non-blocking IO仍然要求process主动check数据是否准备完毕")]),e._v(" "),s("li",[e._v("non-blocking IO在数据准备阶段是non-blocking，在数据拷贝阶段是blocking")]),e._v(" "),s("li",[e._v("asynchronous IO只需在发起IO请求后等待kernel操作完毕后的信号通知即可")]),e._v(" "),s("li",[e._v("asynchronous IO所谓的操作完毕包括数据准备完毕和数据拷贝完毕")])])])}),[],!1,null,null,null);l.default=i.exports}}]);