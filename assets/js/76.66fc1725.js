(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{507:function(_,v,e){"use strict";e.r(v);var t=e(27),l=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"_15-0-前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-0-前言"}},[_._v("#")]),_._v(" 15.0. 前言")]),_._v(" "),e("p",[_._v("何为 "),e("em",[e("strong",[_._v("pointer")])]),_._v(" ：")]),_._v(" "),e("ul",[e("li",[e("em",[e("strong",[_._v("pointer")])]),_._v(" 就是指针")]),_._v(" "),e("li",[_._v("是对某一种变量的统称，这种变量存储了某个内存地址，该地址引用或指向其它数据")])]),_._v(" "),e("p",[_._v("引用是最常用的指针：")]),_._v(" "),e("ul",[e("li",[_._v("Rust 中最常用的指针就是 Chapter4 中的引用")]),_._v(" "),e("li",[_._v("引用通过 & 来标识，并借用所指向的数据")]),_._v(" "),e("li",[_._v("除此之外，引用没有其它的功能，而且不会带来额外的性能损耗")])]),_._v(" "),e("p",[_._v("何为 "),e("em",[e("strong",[_._v("smart pointer")])]),_._v(" ：")]),_._v(" "),e("ul",[e("li",[e("em",[e("strong",[_._v("smart pointer")])]),_._v(" 就是智能指针")]),_._v(" "),e("li",[_._v("智能指针也是指针，但与指针不同的是，它是一种数据结构，包含了额外的 metadata ，也具备了比指针更多的功能")]),_._v(" "),e("li",[_._v("智能指针不是 Rust 独有的概念，它起源于 C++ ，并在很多语言中都存在")]),_._v(" "),e("li",[_._v("Rust 标准库中定义了多种智能指针，提供了远超于引用的更多功能")]),_._v(" "),e("li",[_._v("例如，本章会讲解一种智能指针叫 reference counting ，这种智能指针允许一份数据存在多个所有者，并跟踪所有者的数量，当该数据已经不存在所有者时，就销毁该数据")])]),_._v(" "),e("p",[_._v("引用与智能指针：")]),_._v(" "),e("ul",[e("li",[_._v("Rust 使用了所有权和借用的概念，所以引用和智能指针有显著区别")]),_._v(" "),e("li",[_._v("引用是一种指针，只能 borrow 数据")]),_._v(" "),e("li",[_._v("反过来，大多数智能指针虽然也是指向数据，但可以 own 数据；")])]),_._v(" "),e("p",[_._v("智能指针举例：")]),_._v(" "),e("ul",[e("li",[_._v("到目前为止，本书内容已经涉及过一些智能指针")]),_._v(" "),e("li",[_._v("例如Chapter8 中的 "),e("code",[_._v("String")]),_._v(" 和 "),e("code",[_._v("Vec<T>")]),_._v(" ，但并没有直接称呼它们为智能指针")]),_._v(" "),e("li",[_._v("但事实上，这些类型可以视作智能指针，因为它们拥有内存并允许操作这些内存")]),_._v(" "),e("li",[_._v("而且拥有 metadata ，例如 "),e("code",[_._v("Vec")]),_._v(" 可存储容量")]),_._v(" "),e("li",[_._v("还具备其它的能力，例如 "),e("code",[_._v("String")]),_._v(" 总是能确保其数据是有效的 UTF-8 编码")])]),_._v(" "),e("p",[_._v("智能指针的实现：")]),_._v(" "),e("ul",[e("li",[_._v("智能指针一般通过 struct 来实现")]),_._v(" "),e("li",[_._v("但二者最大的不同是，智能指针实现了 "),e("code",[_._v("Deref")]),_._v(" 和 "),e("code",[_._v("Drop")]),_._v(" 这两个 trait")]),_._v(" "),e("li",[e("code",[_._v("Deref")]),_._v(" 允许结构体实例具备引用的特性，从而该结构体可以是一个引用，也可以是一个智能指针")]),_._v(" "),e("li",[e("code",[_._v("Drop")]),_._v(" 允许定义当结构体实例离开生存周期时的行为")]),_._v(" "),e("li",[_._v("本章会讲解这两个 trait 并可以看到它们对于智能指针的重要性")])]),_._v(" "),e("p",[_._v("在 Rust 中经常会使用智能指针这种通用设计模式，因此很多库都有自己的智能指针，甚至你也可以实现自己的智能指针。所以本章只会讨论标准库中最常用的如下几种智能指针：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("Box<T>")]),_._v(" 可以在 heap 中分配内存和数据")]),_._v(" "),e("li",[e("code",[_._v("Rc<T>")]),_._v(", 一种 reference counting 类型，可以存在多个所有者")]),_._v(" "),e("li",[e("code",[_._v("Ref<T>")]),_._v(" and "),e("code",[_._v("RefMut<T>")]),_._v(", 通过 "),e("code",[_._v("RefCell<T>")]),_._v(" 来访问，这种智能指针在运行时执行借用规则，而不是在编译时")])]),_._v(" "),e("p",[_._v("其它内容：")]),_._v(" "),e("ul",[e("li",[_._v("本章还会涉及到 "),e("em",[e("strong",[_._v("interior mutability")])]),_._v(" ，也就是一个非 mut 类型可以提供API，通过 API 来改变内部数据")]),_._v(" "),e("li",[_._v("还会讨论 "),e("em",[e("strong",[_._v("reference cycle")])]),_._v(" ，它会如何导致内存泄露，以及如何避免")])])])}),[],!1,null,null,null);v.default=l.exports}}]);