(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{498:function(v,_,e){"use strict";e.r(_);var c=e(27),t=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"_16-4-send-sync"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-send-sync"}},[v._v("#")]),v._v(" 16.4. "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")])]),v._v(" "),e("h2",{attrs:{id:"理念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理念"}},[v._v("#")]),v._v(" 理念")]),v._v(" "),e("ul",[e("li",[v._v("有趣的是，rust 语言几乎没有关于并发的特性")]),v._v(" "),e("li",[v._v("本章所讨论的并发特性，几乎都属于标准库，而不是语言本身")]),v._v(" "),e("li",[v._v("但是，在处理并发时，我们不需要局限于 rust 语言和标准库")]),v._v(" "),e("li",[v._v("我们可以开发自己的并发特性，或使用别人已经开发好的")]),v._v(" "),e("li",[v._v("但是，rust 语言中内嵌了几个并发的概念："),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" ，它们属于 trait ，在 "),e("code",[v._v("std::marker")]),v._v(" 中")])]),v._v(" "),e("h2",{attrs:{id:"原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原则"}},[v._v("#")]),v._v(" 原则")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 属于 "),e("em",[e("strong",[v._v("标记")])]),v._v("（"),e("em",[e("strong",[v._v("marker")])]),v._v("）trait ，甚至不需要实现任何方法")]),v._v(" "),e("li",[v._v("这些 trait 可以强制 rust 对并发相关的不变性进行检查")]),v._v(" "),e("li",[v._v("在 rust 中：\n"),e("ul",[e("li",[v._v("几乎所有的 primitive 类型都是 "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")])]),v._v(" "),e("li",[v._v("完全由 "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")]),v._v(" 类型所构成的新类型，也自动是 "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")])])])]),v._v(" "),e("li",[v._v("因此，通常并不需要手动实现 "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")])]),v._v(" "),e("li",[v._v("而手动实现这些标记 trait 会涉及 unsafe 代码，在 Chapter19 会讲解")]),v._v(" "),e("li",[v._v("另外，在构建新的并发类型时，若存在非 "),e("code",[v._v("Send")]),v._v(" & "),e("code",[v._v("Sync")]),v._v(" 类型，则需要格外小心，"),e("a",{attrs:{href:"https://doc.rust-lang.org/stable/nomicon/",target:"_blank",rel:"noopener noreferrer"}},[v._v("The Rustonomicon"),e("OutboundLink")],1),v._v(" 中做了详细讲解")])]),v._v(" "),e("h2",{attrs:{id:"send"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#send"}},[v._v("#")]),v._v(" "),e("code",[v._v("Send")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Send")]),v._v(" 表示这种数据类型对应的所有权可以在线程之间传递")]),v._v(" "),e("li",[v._v("几乎所有的 rust 数据类型都是 "),e("code",[v._v("Send")]),v._v(" ，但也有一些例外，比如 "),e("code",[v._v("Rc<T>")]),v._v(" ：\n"),e("ul",[e("li",[v._v("如果克隆了一个 "),e("code",[v._v("Rc")]),v._v(" 并将所有权交给子线程，则主线程和子线程都可能同时修改引用计数，进一步引起资源管理错误")]),v._v(" "),e("li",[v._v("而事实上，rust 编译器也不会允许这么做：例如在 Chapter16.3 的例子代码中，将 "),e("code",[v._v("Arc<Mutex<i32>>")]),v._v(" 换成 "),e("code",[v._v("Rc<Mutex<i32>>")]),v._v(" ，则编译器会提示 "),e("code",[v._v("the trait Send is not implemented for Rc")]),v._v(" ，但使用 "),e("code",[v._v("Arc<Mutex<i32>>")]),v._v(" 就没有问题")]),v._v(" "),e("li",[v._v("而这些安全保障，就是通过 rust 的类型系统和 trait 限制来做到的")]),v._v(" "),e("li",[v._v("因此，"),e("code",[v._v("Rc<T>")]),v._v(" 是为单线程场景而设计的，它也不需要为了线程安全而付出性能代价")])])]),v._v(" "),e("li",[v._v("对于一种数据类型，如果都由 "),e("code",[v._v("Send")]),v._v(" 类型组成，则这种数据类型自动就是 "),e("code",[v._v("Send")])]),v._v(" "),e("li",[v._v("所有的 primitive 类型都是 "),e("code",[v._v("Send")]),v._v(" ，除了 raw pointer ，在 Chapter19 会讲解")])]),v._v(" "),e("h2",{attrs:{id:"sync"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sync"}},[v._v("#")]),v._v(" "),e("code",[v._v("Sync")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Sync")]),v._v(" 表示这种数据类型可以安全的被多个线程引用")]),v._v(" "),e("li",[e("em",[e("strong",[v._v("规则")])]),v._v("：对于数据类型 "),e("code",[v._v("T")]),v._v(" ，如果 "),e("code",[v._v("&T")]),v._v(" 是 "),e("code",[v._v("Send")]),v._v(" ，则 "),e("code",[v._v("T")]),v._v(" 是 "),e("code",[v._v("Sync")])]),v._v(" "),e("li",[v._v("这个规则的意思是："),e("code",[v._v("&T")]),v._v(" 可以被安全的 "),e("code",[v._v("Send")]),v._v(" 到其它线程")]),v._v(" "),e("li",[v._v("与 "),e("code",[v._v("Send")]),v._v(" 同理，下面这些类型也不是 "),e("code",[v._v("Sync")]),v._v(" ：\n"),e("ul",[e("li",[e("code",[v._v("Rc")])]),v._v(" "),e("li",[e("code",[v._v("RefCell")])]),v._v(" "),e("li",[e("code",[v._v("Cell")])]),v._v(" "),e("li",[v._v("这些类型所实现的借用规则检查（运行时执行），"),e("em",[e("strong",[v._v("并不是")])]),v._v(" 线程安全的")])])]),v._v(" "),e("li",[v._v("而对应的，下面这些类型是 "),e("code",[v._v("Sync")]),v._v(" ：\n"),e("ul",[e("li",[e("code",[v._v("Arc")])]),v._v(" "),e("li",[e("code",[v._v("Mutex")])]),v._v(" "),e("li",[v._v("这些类型所实现的借用规则检查（运行时执行），"),e("em",[e("strong",[v._v("是")])]),v._v(" 线程安全的")])])]),v._v(" "),e("li",[v._v("与 "),e("code",[v._v("Send")]),v._v(" 一样：\n"),e("ul",[e("li",[v._v("对于一种数据类型，如果都由 "),e("code",[v._v("Sync")]),v._v(" 类型组成，则这种数据类型自动就是 "),e("code",[v._v("Sync")])]),v._v(" "),e("li",[v._v("所有的 primitive 类型都是 "),e("code",[v._v("Sync")])])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);